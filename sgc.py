# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SGC
                                 A QGIS plugin
 Sistema Integral de Gesti√≥n Catastral
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-12-15
        git sha              : $Format:%H$
        copyright            : (C) SyK Catastro Sistemas
        email                : sykcatastro.sistemas@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QSize, QThread, pyqtSignal, pyqtSlot, QObject, QItemSelectionModel, QAbstractItemModel, QModelIndex, QUrl,QPoint
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from qgis.PyQt.QtXml import *
from qgis.core import *
from qgis.gui import QgsMapToolIdentify, QgsLayerTreeView, QgsMessageBarItem, QgsMapToolEmitPoint, QgsMapTool, QgsMapToolIdentifyFeature
from PyQt5.QtCore import QAbstractTableModel, QVariant, Qt, QDateTime, QStringListModel, QSortFilterProxyModel, QEvent, QMetaMethod
from PyQt5.QtWidgets import QDesktopWidget, QMessageBox, QHeaderView
from datetime import date, datetime
from pathlib import Path
import requests, re, hashlib, json, logging.config, time, math, copy, os.path, sys, base64, platform, glob
import locale as locale_lib
from decimal import Decimal

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .bandeja_dialog import BandejaDialog
from .login_dialog import LoginDialog
from .pass_dialog import PassDialog
from .edit_tramite_dialog import EditTramiteDialog
from .doc_info_dialog import DocInfoDialog
from .consulta_dialog import ConsultaDialog
from .edit_objeto_grafico_dialog import EditObjetoGraficoDialog

class SGC:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'SGC_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Sistema Integral de Gesti√≥n Catastral')

        # Properties
        self.actions = []
        self.user_actions = []
        self.first_start_BT = True
        self.first_start_Login = True
        self.first_start_ChangePass = True
        self.first_start_EditTramite = True
        self.first_start_DocInfo = True
        self.first_start_Consulta = True
        self.first_start_EditObjetoGrafico = True
        # Data for login/pass change
        self.passChange = False
        self.dataBT = None
        self.lastSortedColumnBT = None
        # Data for Edit Tramite
        self.ETtabDatosEspecificos = False
        self.dataET = None
        # Data for ABM Objetos Gr√°ficos
        self.dataEOG = None
        # List of SGC Layers 
        self.layers = []
        self.dataLayers = None
        # Data for edit tramite
        self.tramiteGroupString =  ""
        # Data for icons for the entire application
        self.current_dir = os.path.dirname(os.path.realpath(__file__))
        # Dialog data for feature selection
        self.dialogs = {"EditTramite": [["dlgET","defaultSizeET"]],
                        "dlgBT": [["dlgBT","defaultSizeBT"]],
                        "dlgET": [["dlgET","defaultSizeET"]],
                        "EditObjetoGrafico": [["dlgEOG","defaultSizeEOG"]],
                        "Consulta": [["dlgC","defaultSizeC"]]}
        # Initialization functions
        self.configFromFile()

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('SGC', message)


    def add_action(
        self,
        icon_path,
        text,
        callback=None,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
        add_to_user_toolbar=False):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        if callback: action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar and not add_to_user_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_user_toolbar:
            # Adds action to logged in user toolbar
            self.user_toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToWebMenu(
                self.menu,
                action)

        if not add_to_user_toolbar:
            self.actions.append(action)
        else:
            self.user_actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        icon_path = ':/plugins/sgc/icon.png'
        login_icon_path = os.path.join(self.current_dir,'icons/login.png')
        # Login Dialog Icon
        self.add_action(
            login_icon_path,
            text=self.tr(u'SGC Login'),
            callback=self.runLogin,
            parent=self.iface.mainWindow())

        # Initiate Logger
        logging.getLogger('PyQt5').setLevel(logging.CRITICAL)
        logging.getLogger('requests').setLevel(logging.CRITICAL)
        logging.basicConfig(format='%(asctime)s - %(message)s',filename=os.path.join(Path.home(),'sgc.log'),level=logging.DEBUG)
        logging.debug("Plugin iniciado")
        # For Esc key connection
        self.shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self.iface.mainWindow())
        self.shortcut.setContext(Qt.ApplicationShortcut)
        self.shortcut.activated.connect(self.escPressed)
        self.featSelDlg = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Sistema Integral de Gesti√≥n Catastral'),
                action)
            self.iface.removeToolBarIcon(action)
        self.logout(True)


    def logout(self, skip_question = False):
        if not skip_question:
            message = QMessageBox(QMessageBox.Question, "Cerrar sesi√≥n", "¬øEst√° seguro de que desea cerrar la sesi√≥n actual?",
                QMessageBox.Yes|QMessageBox.No, self.iface.mainWindow())
            message.buttons()[0].setText("Si") 
            reply = message.exec()
        else:
            reply = QMessageBox.Yes
        if reply == QMessageBox.Yes:
            # Menus, toolbars, and UI elements
            if self.iface.mainWindow().findChild(QToolBar, "SGC"):
                toolbar = self.iface.mainWindow().findChild(QToolBar, "SGC")
                # This removes the toolbar but doesn't delete it
                self.iface.mainWindow().removeToolBar(toolbar)
                # This deletes it
                toolbar.setParent(None)
                self.user_actions = []
                # Show Login/Other buttons once again
                for action in self.actions:
                    action.setVisible(True)
            # Logs and notifications
            if hasattr(self, 'user_data') and hasattr(self.user_data, 'Id_Usuario'):
                self.iface.messageBar().pushMessage("Sesi√≥n cerrada", "Cerrada sesi√≥n de usuario ",level=Qgis.Success, duration=3)
                logging.info("Cerrada sesi√≥n de usuario " +
                    str(self.user_data['Id_Usuario']) + " - " +
                    str(self.user_data['Nombre']) + " " +
                    str(self.user_data['Apellido']))
                # Data
                self.user_data = None
                self.TOKEN = None
                self.funciones = None
            # Remove layers from map
            if hasattr(self, 'dataLayers') and self.dataLayers is not None and "grupos" in self.dataLayers:
                # Just in case, remove temporarily added group
                self.loadTramiteLayerGroup(True)
                # Remove groups/layers from database
                for g in self.dataLayers["grupos"]:
                    root = QgsProject.instance().layerTreeRoot()
                    group = root.findGroup(g["nombre"])
                    if group is not None:
                        for child in group.children():
                            if isinstance(child,QgsLayerTreeGroup):
                                root.removeChildNode(child)
                            else:
                                QgsProject.instance().removeMapLayer(child.layerId())
                        root.removeChildNode(group)
                # Remove "Dibujos" group
                group = root.findGroup("Dibujos")
                if group is not None:
                    for child in group.children():
                        if isinstance(child,QgsLayerTreeGroup):
                            root.removeChildNode(child)
                        else:
                            QgsProject.instance().removeMapLayer(child.layerId())
                    root.removeChildNode(group)
            self.layers = []
            self.dataLayers = None
            self.iface.mapCanvas().refresh()
    """
        Logged user toolbar functions and definitions
    """
    def enableToolBar(self,data_user):
        if not self.iface.mainWindow().findChild(QToolBar, "SGC"):
            logging.info("A√±adida barra de herramientas de usuario")
            # Icons
            icon_path = ':/plugins/sgc/icon.png'
            #password_icon_path = os.path.join(self.current_dir,'icons/password.png')
            logout_icon_path = os.path.join(self.current_dir, 'icons/logout2.png')
            tray_icon_path = os.path.join(self.current_dir, 'icons/tray.png')
            consulta_icon_path = os.path.join(self.current_dir, 'icons/consulta.png')
            edit_objetos_graficos_icon_path = os.path.join(self.current_dir, 'icons/objetos_graficos.png')
            sanear_icon_path = os.path.join(self.current_dir, 'icons/sanear.png')
            # Toolbar            
            self.user_toolbar = self.iface.addToolBar("SGC")
            self.user_toolbar.setObjectName("SGC")
            # Bandeja de Tr√°mite
            if '502' in self.funciones: # "Bandeja de tr√°mite"
                self.add_action(tray_icon_path,
                    text='Bandeja de tr√°mites',
                    callback=self.runBandeja,
                    parent=self.user_toolbar,
                    add_to_user_toolbar=True)
            # B√∫squeda/Consulta
            if '507' in self.funciones: # "Consulta Alfanum√©rica"
                self.add_action(consulta_icon_path,
                    text='Consulta Alfanum√©rica',
                    callback=self.runConsulta,
                    parent=self.user_toolbar,
                    add_to_user_toolbar=True)
            # ABM Objetos Gr√°ficos
            if '508' in self.funciones: # "ABM Objetos Gr√°ficos"
                self.add_action(edit_objetos_graficos_icon_path,
                    text='ABM Objetos Gr√°ficos',
                    callback=self.runEditObjetosGraficos,
                    parent=self.user_toolbar,
                    add_to_user_toolbar=True)
            # Separator
            self.user_toolbar.addSeparator()
            # Login/Logout buttons
            self.add_action(
                icon_path="",
                text="Usuario: " + data_user["Nombre"] + " " + data_user["Apellido"],
                callback=None,
                parent=self.user_toolbar,
                add_to_user_toolbar=True)
            self.add_action(
                icon_path=logout_icon_path,
                text="Salir",
                callback=self.logout,
                parent=self.user_toolbar,
                add_to_user_toolbar=True)
            # Hide Login/Other buttons whenever we're logged in
            for action in self.actions:
                action.setVisible(False)
    """
        -------------
    """
    def configFromFile(self):
        """ Defaults to "http://localhost:5000/" if file not found or no URL in config file """
        config_dir = os.path.join(self.current_dir,'config.ini')
        self.URL = "http://localhost:5020/"
        try:
            with open(config_dir, 'r') as f:
                line_content = f.readline()
                while line_content:
                    URL = re.search('(?<=^URL=).*', line_content)
                    if URL:
                        self.URL = URL.group(0).strip()
                        break
                    line_content = f.readline()
        except IOError: pass

    def toggleEnableToolbarIcons(self, closing = True):
        if self.whichDialog == "EditTramite" and not closing:
            self.loadTramiteLayerGroup(True)
            self.maximizeDialog("dlgBT")
            self.dlgBT.activateWindow()
            return
        if closing:
            self.whichDialog = None # Dialog name is reset
        for a in self.actions:
            a.setEnabled(closing)
        for a in self.user_actions:
            a.setEnabled(closing)
        self.classType = None

    """

        SECURITY METHODS

    """
    def securityBandejaTramite(self):
        bandeja_logic = '503' in self.funciones and ('505' in self.funciones or ('504' in self.funciones and '506' in self.funciones)) # "Procesar tr√°mite"  "Asociar geometr√≠as" "Desasociar geometr√≠as" "Validar tr√°mite"
        self.dlgBT.okButton.setVisible(bandeja_logic)
        try: self.dlgBT.tableTramites.itemDoubleClicked.disconnect()
        except (KeyboardInterrupt, SystemExit): raise
        except: pass
        if bandeja_logic: self.dlgBT.tableTramites.itemDoubleClicked.connect(self.procesarTramite)

    def securityEditTramite(self):
        self.dlgET.asociarButton.setVisible('504' in self.funciones) # "Asociar Geometr√≠as"
        self.dlgET.desasociarButton.setVisible('505' in self.funciones) # "Desasociar Geometr√≠as"

    def securityABMObjetosGraficos(self):
        self.dlgEOG.buttonDesasociar.setVisible('509' in self.funciones) # "Eliminar gr√°fico"
        self.dlgEOG.buttonAsociar.setVisible('511' in self.funciones) # "Seleccionar nueva geometr√≠a"


    """

        ------

    """



    """
        THREADED WORKER NETWORK REQUESTS
    """
    class WaitMessage(QThread):
        #finished = pyqtSignal()
        #failed = pyqtSignal()
        def __init__(self, outer_self,message):
            self.outer = outer_self
            self.msg = None
            self.message = message
            super(SGC.WaitMessage, self).__init__(outer_self.iface)
        
        @pyqtSlot()
        def doneMessage(self):
            self.msg.done(0)

        def run(self):
            self.msg = QMessageBox()
            # Get path of .gif in plugin folder
            gif_path = os.path.join(self.outer.current_dir,'icons/cogs1.gif')
            # Create Label
            pixmap = QPixmap(gif_path)
            pixmap = pixmap.scaled(120,120,Qt.KeepAspectRatio)
            msg.setIconPixmap(pixmap)
            icon_label = self.msg.findChild(QLabel, "qt_msgboxex_icon_label")
            # Define gif
            movie = QMovie(gif_path)
            movie.setScaledSize(QSize(120,120))
            # Replace static image Icon with gif
            setattr(self.msg, 'icon_label', movie) # avoid garbage collector
            icon_label.setMovie(movie)
            movie.start()
            # Set window text and buttons
            self.msg.setWindowTitle("Cargando formulario...")
            self.msg.setModal(True)
            self.msg.setText(self.message if self.message != "" else "Espere mientras se carga el formulario...")
            self.msg.rejected.connect(self.msg.close)
            self.msg.setStandardButtons(QMessageBox.Cancel)
            self.msg.buttons()[0].setText("Cerrar")
            self.msg.show()
            return self.msg

    class ServerLoaderDBLayers(QThread):
        finished = pyqtSignal()
        failed = pyqtSignal()
        def __init__(self, outer_self):
            self.outer = outer_self
            super(SGC.ServerLoaderDBLayers, self).__init__(outer_self.iface)
        def run(self):
            try:
                r = requests.get(url = self.outer.URL + "layers", 
                                 headers={'Authorization': "Bearer {}".format(self.outer.TOKEN)})
                if r.status_code == 200:
                    self.outer.dataLayers = json.loads(r.text)
                    self.finished.emit()
                else:
                    logging.warning("Acceso no autorizado")
                    self.failed.emit()
            except requests.exceptions.ConnectionError:
                logging.warning("Error en servidor")
                self.failed.emit() # Close waiting dialog

    class ServerLoaderTramiteDatos(QThread):
        finished = pyqtSignal()
        failed = pyqtSignal(str)
        def __init__(self, outer_self,id_tramite):
            self.outer = outer_self
            self.id_tramite = int(id_tramite)
            super(SGC.ServerLoaderTramiteDatos, self).__init__(outer_self.iface)
        def run(self):
            try:
                r = requests.get(url = self.outer.URL + f"tramite/{self.id_tramite}",
                                 headers={'Authorization': "Bearer {}".format(self.outer.TOKEN)})
                result = json.loads(r.text)
                if r and r.status_code == 200 and 'ERROR' not in result:
                    self.outer.dataET = result
                    self.finished.emit()
                else:
                    self.failed.emit("db") 
            except requests.exceptions.ConnectionError:
                self.failed.emit("server")
            except (KeyboardInterrupt, SystemExit): raise
            except: self.failed.emit("server")
            
    class ServerLoaderBandejaTramites(QThread):
        finished = pyqtSignal()
        failed = pyqtSignal(str)
        def __init__(self, outer_self,page):
            self.outer = outer_self
            self.page = page
            super(SGC.ServerLoaderBandejaTramites, self).__init__(outer_self.iface)
        def run(self):
            try:
                r = requests.get(url = self.outer.URL + "tramite/all", #data = {"page": self.page},
                                 headers={'Authorization': "Bearer {}".format(self.outer.TOKEN)})
                result = json.loads(r.text)
                if r and r.status_code == 200 and 'ERROR' not in result:
                    self.outer.dataBT = result
                    self.finished.emit()
                else:
                    self.failed.emit("db") 
            except requests.exceptions.ConnectionError:
                self.failed.emit("server")
            except (KeyboardInterrupt, SystemExit): raise
            except: self.failed.emit("server")

    class ServerLoaderChangePass(QThread):
        finished = pyqtSignal()
        failed = pyqtSignal(str)
        def __init__(self, outer_self, data):
            self.outer = outer_self
            self.data = data
            super(SGC.ServerLoaderChangePass, self).__init__(outer_self.iface)
        def run(self):
            try:
                r = requests.post(url = self.outer.URL + "user/pass", data = self.data, 
                                 headers={'Authorization': "Bearer {}".format(self.outer.TOKEN)})
                result = json.loads(r.text)
                if r and r.status_code == 200 and 'ERROR' not in result:
                    self.finished.emit()
                else:
                    self.failed.emit("db") # Close waiting dialog
            except requests.exceptions.ConnectionError:
                self.failed.emit("server") # Close waiting dialog
            except (KeyboardInterrupt, SystemExit): raise
            except: self.failed.emit("server")

    class ServerLoaderLogin(QThread):
        finished = pyqtSignal()
        failed = pyqtSignal(str)
        pass_change_required = pyqtSignal()
        def __init__(self, outer_self, data):
            self.outer = outer_self
            self.data = data
            super(SGC.ServerLoaderLogin, self).__init__(outer_self.iface)
        def run(self):
            try:
                r = requests.post(url = self.outer.URL + "auth", data = self.data)
                self.outer.user_data = json.loads(r.text)
                if r and 'ERROR' not in self.outer.user_data and 'ERROR_PERMISOS' not in self.outer.user_data and "TIMEOUT" not in self.outer.user_data:
                    if self.outer.user_data['user']['Cambio_pass']:
                        self.pass_change_required.emit()
                    else:
                        self.finished.emit()
                else:
                    self.failed.emit("db") # Close waiting dialog
            except requests.exceptions.ConnectionError:
                self.failed.emit("server") # Close waiting dialog
            except (KeyboardInterrupt, SystemExit): 
                raise
            except:
                self.failed.emit("server")

    class ServerLoaderUpdateGeometryEOG(QThread):
        finished = pyqtSignal()
        failed = pyqtSignal(str)
        def __init__(self, outer_self, data, asociar):
            self.outer = outer_self
            self.data = data
            self.asociar = asociar
            super(SGC.ServerLoaderUpdateGeometryEOG, self).__init__(outer_self.iface)
        def run(self):
            try:
                r = requests.put(url = self.outer.URL + "objeto_geometry", data = json.dumps(self.data),headers={'Authorization': "Bearer {}".format(self.outer.TOKEN)})
                self.outer.dataEOG = r.json()
                self.outer.dataEOG["asociar"] = self.asociar
                if r.status_code == 200:
                    self.finished.emit()
                else:
                    self.failed.emit("db") # Close waiting dialog
            except requests.exceptions.ConnectionError:
                logging.warning("Error en servidor")
                self.failed.emit("server") # Close waiting dialog
            except (KeyboardInterrupt, SystemExit): 
                raise
            except:
                logging.warning("ERROR : " + str(sys.exc_info()[0]) + str(sys.exc_info()[1])  + str(sys.exc_info()[2]) + "Line: " + str(sys.exc_info()[2].tb_lineno))
                self.failed.emit("other_error")

    """
        GENERAL FUNCTIONS
    """
    def initialZoom(self):
        canvas = self.iface.mapCanvas()
        scale = self.dataLayers["initial_zoom"]["scale"]
        x = self.dataLayers["initial_zoom"]["x"]
        y = self.dataLayers["initial_zoom"]["y"]
        rect = QgsRectangle(x - scale, y - scale, x + scale, y + scale)
        canvas.setExtent(rect)
        canvas.refresh()

    class IdentifyTool(QgsMapTool):
        found_feats = pyqtSignal(list)
        def __init__(self, canvas, layers):
            QgsMapTool.__init__(self, canvas)
            self.canvas = canvas
            self.layers = layers

        def canvasPressEvent(self, event):
            QgsMapTool.canvasPressEvent(self, event)
            pos = self.toMapCoordinates(event.pos())
            result = []
            try:
                for layer in self.layers:
                    circle = QgsGeometry.fromPointXY(QgsPointXY(pos.x(),pos.y())).buffer(0.00001 if layer.name() != 'Localidades' else 2000,5)
                    features = layer.getFeatures()
                    for feat in features:
                        if circle.intersects(feat.geometry()) or circle.contains(feat.geometry()):
                            result.append(feat)
            except (KeyboardInterrupt, SystemExit): raise
            except: pass
            if len(result) > 0:
                self.found_feats.emit(result)

        def deactivate(self):
            try: # Have to use a try/except construct since disconnect() loves throwing exceptions
                self.canvas.unsetMapTool(self)
            except (KeyboardInterrupt, SystemExit): raise
            except: pass

    def abortFeatureSelect(self):
        try: self.selectFeatureMsg.dismiss()
        except (KeyboardInterrupt, SystemExit): raise
        except: pass

        self.maximizeDialog(self.whichDialog)
            
        #Remove feature selection event
        try: 
            self.mapTool.found_feats.disconnect()
            self.mapTool.deactivate()
        except (KeyboardInterrupt, SystemExit): raise
        except: pass
        self.featSelDlg = False

    def escPressed(self):
        if self.featSelDlg: self.abortFeatureSelect()

    def minimizeDialog(self,dialog = None):
        if dialog in self.dialogs:
            dialogs = self.dialogs[dialog]
            for d in dialogs:
                dlg = getattr(self,d[0],None)
                if dlg is not None:
                    dlg.setMinimumSize(0,0)
                    dlg.resize(0,0)

    def maximizeDialog(self,dialog = None):
        if dialog in self.dialogs:
            dialogs = self.dialogs[dialog]
            for d in dialogs:
                dlg = getattr(self,d[0],None)
                size = getattr(self,d[1],None)
                if dlg is not None:
                    dlg.setMaximumSize(size)
                    dlg.setMinimumSize(size)
                    dlg.resize(size)

    def selectMapFeatureByClick(self,capa = ""):
        search_layers = []
        for l in self.layers:
            if l["fisico"] == capa or l["fisico"] in ["VW_PARCELAS_SANEAR"]:
                search_layers.append(l["obj"])
        self.minimizeDialog(self.whichDialog)
        
        self.selectFeatureMsg = QgsMessageBarItem("Seleccione un objeto de la capa correspondiente al objeto a asociar, haciendo click con el mouse. Cuando lo haga, espere un momento dicho proceso. Tecla ESC para cancelar",level=Qgis.Info, duration=0)
        self.iface.messageBar().pushItem(self.selectFeatureMsg)
        # Connection with map feature selection tool
        canvas = self.iface.mapCanvas()
        self.mapTool = self.IdentifyTool(canvas, search_layers)
        canvas.setMapTool(self.mapTool)
        self.mapTool.found_feats.connect(self.featureSelected)
        self.featSelDlg = True # Allow to abort selection with Esc key
        

    def featureSelected(self, features):
        """ Trigger event for the selection of a polygon/feature in current layer """
        for f in features:
            feature = features[0]
        self.abortFeatureSelect()
        if self.whichDialog == "EditTramite":
            self.featureAsociadaET(feature)
        if self.whichDialog == "EditObjetoGrafico":
            self.EOGupdateGeometria(asociar = True, feature = feature)
    
 
    """
        --- END ---
    """


    """
        METHOD FUNCTIONS
    """
    # Wait dialog
    def messageWait(self, message = ""):
        """ Waiting dialog"""
        msg = QMessageBox()
        # Get path of .gif in plugin folder
        gif_path = os.path.join(self.current_dir,'icons/cogs1.gif')
        # Create Label
        pixmap = QPixmap(gif_path)
        pixmap = pixmap.scaled(120,120,Qt.KeepAspectRatio)
        msg.setIconPixmap(pixmap)
        icon_label = msg.findChild(QLabel, "qt_msgboxex_icon_label")
        # Define gif
        movie = QMovie(gif_path)
        movie.setScaledSize(QSize(120,120))
        # Replace static image Icon with gif
        setattr(msg, 'icon_label', movie) # avoid garbage collector
        icon_label.setMovie(movie)
        movie.start()
        # Set window text and buttons
        msg.setWindowTitle("Cargando formulario...")
        msg.setModal(True)
        msg.setText(message if message != "" else "Espere mientras se carga el formulario...")
        msg.rejected.connect(msg.close)
        msg.setStandardButtons(QMessageBox.Cancel)
        msg.buttons()[0].setText("Cerrar")
        msg.show()
        return msg

    # Change Password
    def unfocusedChangePass(self):
        if self.dlgPass.lineEdit_pw_1.text() != "" and self.dlgPass.lineEdit_pw_1.text() == self.dlgPass.lineEdit_pw_2.text():
            self.dlgPass.pushButton.setEnabled(True)
            self.dlgPass.pushButton.setToolTip("")
        else:
            self.dlgPass.pushButton.setEnabled(False)
            self.dlgPass.pushButton.setToolTip("Las contrase√±as deben coincidir")
    
    def passChangeRequired(self):
        self.waitMsg.done(0)
        self.passChange = True
        self.funciones = self.user_data['funciones']
        self.TOKEN = self.user_data['TOKEN']
        self.user_data = self.user_data['user']
        QMessageBox.information(self.iface.mainWindow(), "Cambio de contrase√±a", "Debe cambiar de contrase√±a para completar el proceso de inicio de sesi√≥n")
        self.runChangePass()

    # Login
    def attemptLogin(self, super = False):
        self.superLogin = super
        data = {'user' : self.dlgLG.lineEdit_user.text(),
                'pass': hashlib.md5(self.dlgLG.lineEdit_pw.text().encode("utf-8")).hexdigest()}
        self.waitMsg = self.messageWait("Espere mientras se verifican sus datos...")
        thread = self.ServerLoaderLogin(self, data)
        thread.finished.connect(self.finishedLogin)
        thread.failed.connect(self.failedLogin)
        thread.pass_change_required.connect(self.passChangeRequired)
        thread.start()

    def finishedLogin(self): 
        self.waitMsg.done(0)
        self.waitMsg.close()
        self.funciones = self.user_data['funciones']
        self.TOKEN = self.user_data['TOKEN']
        self.user_data = self.user_data['user']
        logging.info('Usuario logueado: ' +
            str(self.user_data['Id_Usuario']) +
            " - " + str(self.user_data['Nombre']) +
            " " + str(self.user_data['Apellido']))
        self.iface.messageBar().pushMessage(
            "¬°√âxito!", "Login exitoso",level=Qgis.Success, duration=3)
        self.enableToolBar(self.user_data)
        self.dlgLG.close()
        # After succesful login, attempt to bring up the DB Layers
        thread = self.ServerLoaderDBLayers(self)
        thread.finished.connect(self.loadDBLayers)
        thread.failed.connect(self.failedDBLayers)
        thread.start()

    def failedLogin(self, type):
        self.waitMsg.done(0)
        if type == "db" and self.user_data and 'ERROR' in self.user_data:
            logging.warning("Intento de login fallido")
            QMessageBox.warning(self.dlgLG, "Login Error", "Usuario o Contrase√±a inv√°lidos")
        elif type == "db" and self.user_data and 'ERROR_PERMISOS' in self.user_data:
            QMessageBox.warning(self.dlgLG, "Login Error", "El usuario ingresado no posee permisos para acceder a la aplicaci√≥n")
            logging.warning("Intento de login usuario sin permisos: " + self.dlgLG.lineEdit_user.text() + " - " + self.dlgLG.lineEdit_pw.text())
        elif type == "server":
            if self.superLogin:
                self.attemptLogin(super = True)
            else:
                logging.warning("Error en servidor")
                QMessageBox.warning(self.dlgLG, "Error", "Servidor no disponible.")
        else:
            if self.superLogin:
                self.attemptLogin(super = True)
            else:
                logging.warning("LOGIN ERROR")
                QMessageBox.warning(self.dlgLG, "Login Error", "Error al intentar ingresar.")

    def failedDBLayers(self):
        self.iface.messageBar().pushMessage(
           "Layers SGC", "Error al cargar las layers de la base de datos.",level=Qgis.Warning, duration=3)

    # Load DB Layer at startup
    def loadDBLayers(self):
        # Delete previous layer files
        layer_path = os.path.join(self.current_dir,"temp","")
        files = glob.glob(f"{layer_path}*.qlr")
        for f in files:
            os.remove(f)
        # Remove layers from map
        if hasattr(self, 'dataLayers') and self.dataLayers is not None and "grupos" in self.dataLayers:
                # Just in case, remove temporarily added group
                self.loadTramiteLayerGroup(True)
                # Remove groups/layers from database
                for g in self.dataLayers["grupos"]:
                    root = QgsProject.instance().layerTreeRoot()
                    group = root.findGroup(g["nombre"])
                    if group is not None:
                        for child in group.children():
                            if isinstance(child,QgsLayerTreeGroup):
                                root.removeChildNode(child)
                            else:
                                QgsProject.instance().removeMapLayer(child.layerId())
                        root.removeChildNode(group)
                # Remove "Dibujos" group
                group = root.findGroup("Dibujos")
                if group is not None:
                    for child in group.children():
                        if isinstance(child,QgsLayerTreeGroup):
                            root.removeChildNode(child)
                        else:
                            QgsProject.instance().removeMapLayer(child.layerId())
                    root.removeChildNode(group)
        # Add parent root groups
        self.groups = [] # List of all groups 
        root_groups = list(filter(lambda l: l["padre"] is None,self.dataLayers["grupos"]))
        root_groups.sort(key=lambda l: l['id'],reverse=False)
        for r in root_groups:
            self.groups.append({"id": r["id"], "inicial": r["inicial"],"obj": QgsProject.instance().layerTreeRoot().addGroup(r["nombre"])})
            parent = self.groups[-1]
            # Add first level nested groups in order
            first_nest = list(filter(lambda l: l["padre"] == r["id"],self.dataLayers["grupos"]))
            first_nest.sort(key=lambda l: l['id'],reverse=False)
            for g in first_nest:
                self.groups.append({"id": g["id"],"inicial": g["inicial"], "obj": parent["obj"].addGroup(g["nombre"])})
        # Add rest of the groups
        remaining_groups = [r for r in self.dataLayers["grupos"] if r["id"] not in [g["id"] for g in self.groups]]
        added = 0
        while added < len(remaining_groups):
            for g in remaining_groups:
                if g["padre"] in [f["id"] for f in self.groups] and g["id"] not in [f["id"] for f in self.groups]:
                    temp_parent = list(filter(lambda l: l["id"] == g["padre"],self.groups))[0]
                    self.groups.append({"id": g["id"], "inicial": g["inicial"],"obj": temp_parent["obj"].addGroup(g["nombre"])})
                    added += 1
        # Add temp directory if it doesn't exist
        try: os.mkdir(os.path.join(self.current_dir,"temp"))
        except FileExistsError: pass
        # Layers add
        for l in self.dataLayers["layers"]:
            if l["estilo"] is not None:
                # Check if group exists and is "inicial"
                group = list(filter(lambda g: g["id"] == l["grupo"] and g["inicial"] is True,self.groups))
                if len(group) > 0:
                    group = group[0]["obj"]            
                    qgis_layers = QgsProject.instance().mapLayers().keys() # Save previous list of loaded layers
                    layer_path = os.path.join(self.current_dir,f"temp/{l['nombre']}.qlr")
                    f = open(layer_path, "x")
                    f.write(l["estilo"])
                    f.close()
                    layer_add_result = QgsLayerDefinition().loadLayerDefinition(layer_path,QgsProject.instance(),group)
                    os.remove(layer_path)
                    # If adding was succesful
                    if (layer_add_result[0]):
                        # save newly added layer by obtaining the current list of layers minus the previous list of layers
                        new_layer = QgsProject.instance().mapLayers()[list(set(QgsProject.instance().mapLayers()) - set(qgis_layers))[0]] 
                        if l["nombre_fisico"] is not None and l["nombre_fisico"].find("DIBUJO:") != -1:
                            new_layer.startEditing()
                        self.layers.append({"id": l["id"], 
                                            "tabla": l["tabla"],
                                            "tipo": "oms" if l["tipo"] == 0 else "", 
                                            "fisico": l["nombre_fisico"],
                                            "obj": new_layer,
                                            "default_visible": l["visible"]})
         
        # Project coordinate
        QgsProject.instance().setCrs(QgsCoordinateReferenceSystem(self.dataLayers["crs"]))
        # Do a zoom into Corrientes
        self.initialZoom()
        # Set layer visibility
        for l in self.dataLayers["layers"]:
            found_layer = [lay["obj"] for lay in self.layers if "id" in lay and lay["id"] == l["id"]]
            if len(found_layer)  > 0:
                layer = QgsProject.instance().layerTreeRoot().findLayer(found_layer[0])
                if layer is not None:
                    layer.setItemVisibilityChecked(l["visible"])
                    
        # Collapse layer groups
        nodes = QgsProject.instance().layerTreeRoot().children()

        for n in nodes:
            if isinstance(n, QgsLayerTreeGroup):
                if n.isExpanded() == True:
                    n.setExpanded(False)


    # Bandeja Tramites
    def featureAsociadaET(self, feature):
        try:
            # Definir funci√≥n error_inesperado local
            def error_inesperado():
                mensaje = (
                    "‚ùå Se produjo un error inesperado en la operaci√≥n.\n"
                    "Por favor, siga estas indicaciones:\n"
                    "* Intente nuevamente la operaci√≥n. Antes de repetirla, guarde su geometr√≠a, cierre la aplicaci√≥n y vuelva a abrirla.\n"
                    "* Si el problema persiste, intente m√°s tarde.\n"
                    "* En caso de continuar el inconveniente, tome una captura de pantalla y env√≠e la informaci√≥n asociada al √°rea de sistemas para su an√°lisis."
                )
                errores_verificacion.append(mensaje)
                return True
            
            try:
                item = self.dlgET.entradasTree.model().itemFromIndex(self.dlgET.entradasTree.selectionModel().selectedIndexes()[0]).data()
            except Exception as e:
                error_inesperado()
                
            
            print('iTEM: ', item)
            
            # Datos b√°sicos con validaci√≥n
            try:
                id_objeto = item["id_objeto"]
                id_padres = [i["id_padre"] for i in self.dataET["entradas"] if i["id_objeto"] == id_objeto]
            except Exception as e:
                error_inesperado()
                
            
            # Obtener capa asociada al feature de forma m√°s eficiente
            try:
                featureLayer = next((l["obj"] for l in self.layers if l["fisico"] == f"DIBUJO:{item['tabla']}"), None)
                layer_parcelas = [lay["obj"] for lay in self.layers if lay["fisico"] in ["VW_PARCELAS_GRAF_ALFA", "VW_PARCELAS_GRAF_ALFA_RURALES", "VW_PARCELAS_PH", "VW_PARCELAS_REPUTACION_DOMINIO", "VW_PARCELAS_REGULARIZACION_DOMINIAL", "VW_UNIDADES_PARCELARIAS"]]
            except Exception as e:
                error_inesperado()
                
            
            # ========== Verificaciones =========
            errores_verificacion = []
            
            try:
                geom_feature = feature.geometry()
            except Exception as e:
                error_inesperado()
                
            
            bandera_fuera_contencion = False
            
            # Validaci√≥n geometr√≠a b√°sica
            try:
                if not geom_feature.isGeosValid():
                    errores_verificacion.append("La geometr√≠a que se intenta asociar es inv√°lida. Verifique minuciosamente el dibujo e intente nuevamente.")
            except Exception as e:
                error_inesperado()
                
            
            try:
                area_feature = geom_feature.area()
            except Exception as e:
                error_inesperado()
                
            
            # C√ÅLCULO DE TOLERANCIA SEG√öN ART. 148 DECRETO LEY 2283/68
            try:
                perimetro_feature = geom_feature.length()  # per√≠metro del feature
                capa = item.get('tabla', "").strip()
                if capa in ["VW_PARCELAS_GRAF_ALFA", "VW_PARCELAS_PH"]:
                    # Urbano - Tolerancia reducida seg√∫n normativa
                    T = (0.0002 * perimetro_feature + 0.003)
                else:
                    # Rural - Tolerancia est√°ndar
                    T = (0.0004 * perimetro_feature + 0.25) 
                
                T_2 = T * T # Es equivalente a T¬≤ 
            except Exception as e:
                error_inesperado()
                
            
            # Preparar geometr√≠as padre
            nombre_layer_padre = "TEMPORAL:PARCELAS"
            try:
                layer_padre = next((lay["obj"] for lay in self.layers if lay["fisico"] == nombre_layer_padre), None)
                padre_geom = []
                
                if layer_padre and id_padres:
                    # Obtener todas las geometr√≠as padre en una sola consulta
                    expr = QgsExpression(f"\"id\" in ({','.join(map(str, id_padres))})")
                    request = QgsFeatureRequest(expr)
                    padre_geom = [f.geometry() for f in layer_padre.getFeatures(request)]
            except Exception as e:
                error_inesperado()
                
            
            # ========== PREPARACI√ìN √öNICA DE GEOMETR√çA FUSIONADA ==========
            fusion_geom = None
            try:
                if padre_geom:
                    if len(padre_geom) == 1:
                        fusion_geom = padre_geom[0]
                    else:
                        fusion_geom = padre_geom[0]
                        for p in padre_geom[1:]:
                            fusion_geom = fusion_geom.combine(p)
                    # Limpieza topol√≥gica m√≠nima UNA SOLA VEZ
                    fusion_geom = fusion_geom.buffer(0, 1)
            except Exception as e:
                error_inesperado()
                

            # Validaci√≥n de padre necesario (excepto casos especiales)
            try:
                tramite_objeto = str(self.dataET["tramite"]["objeto"])
                excepciones_tramite = [
                    'Adjudicaci√≥n de partida inmobiliaria', # 0
                    'Desglose', # 1
                    'Divisi√≥n en Base a Mensura Registrada Para Prescripci√≥n adquisitiva', # 2
                    'Mensura Para Prescripci√≥n Adquisitiva', # 3
                    'Mensura Para Prescripci√≥n Adquisitiva y Divisi√≥n', # 4
                    'Mensura para reputacion de dominio', # 5
                    'Mensura para reputacion de dominio y divisi√≥n', # 6
                    'Mensura Para Prescripci√≥n Administrativa Ley N¬∞ 24320', # 7
                    'Mensura para Plan de Regularizaci√≥n Dominial seg√∫n Ley 5836/2008 y modificatoria Ley 6211/2013', # 8
                    'Mensura De Divisi√≥n de la Edificaci√≥n Existente Para Someter al R√©gimen de Propiedad Horizontal en Base a Mensura Registrada', # 9
                    'Mensura de Divisi√≥n de la Edificaci√≥n Existente y a Construir Para Someter al R√©gimen de Propiedad Horizontal en Base a Mensura Registrada', # 10
                    'Mensura de Modificaci√≥n de la Divisi√≥n de la Edificaci√≥n Existente Para Someter al R√©gimen de Propiedad Horizontal en Base a Mensura Registrada', # 11
                    'Propiedad Horizontal' # 12
                ]

                # ========== VALIDACI√ìN SIMPLIFICADA Y ACELERADA PARA PRESCRIPCI√ìN ==========
                prescripciones_multiples = [
                    'Mensura Para Prescripci√≥n Adquisitiva',
                    'Mensura Para Prescripci√≥n Adquisitiva y Divisi√≥n',
                    'Mensura Para Prescripci√≥n Administrativa Ley N¬∞ 24320',
                    'Mensura para Plan de Regularizaci√≥n Dominial seg√∫n Ley 5836/2008 y modificatoria Ley 6211/2013'
                ]
            except Exception as e:
                error_inesperado()
                

            try:
                if tramite_objeto in prescripciones_multiples and fusion_geom:
                    print(f"üîç Validaci√≥n para prescripci√≥n con {len(id_padres)} origen(es)")

                    # Asegurar geometr√≠as v√°lidas UNA SOLA VEZ
                    if not geom_feature.isGeosValid():
                        geom_feature = geom_feature.buffer(0, 1)

                    # Calcular intersecci√≥n
                    intersect_area = fusion_geom.intersection(geom_feature).area() or 0
                    area_hijo = geom_feature.area() or 0

                    print(f"üîç √Årea de intersecci√≥n total: {intersect_area:.6f} m¬≤ (m√≠nimo {T_2:.6f} m¬≤)")

                    if intersect_area < T_2:
                        bandera_fuera_contencion = True
                        errores_verificacion.append(
                            f"La geometr√≠a destino no intersecta suficientemente la geometr√≠a origen fusionada "
                            f"(m√≠nimo {T_2:.6f} m¬≤). Intersecci√≥n actual: {intersect_area:.6f} m¬≤"
                        )
                    else:
                        print("‚úÖ Relaci√≥n geom√©trica v√°lida entre destino y or√≠genes")
            except Exception as e:
                error_inesperado()
                

            # ========== VALIDACIONES EXISTENTES (CONTINUACI√ìN) ==========
            try:
                if item["anidacion"] > 0 and tramite_objeto not in excepciones_tramite[2:9] and bool(id_padres) and not padre_geom:
                    errores_verificacion.append("Se debe asociar el objeto gr√°fico padre primero")
            except Exception as e:
                error_inesperado()
                
            
            # Validaci√≥n contenido en padre (caso m√∫ltiple) usando geometr√≠a fusionada ya calculada
            try:
                if fusion_geom and tramite_objeto not in prescripciones_multiples:
                    # Asegurar geometr√≠a v√°lida UNA SOLA VEZ
                    if not geom_feature.isGeosValid():
                        geom_feature = geom_feature.buffer(0, 1)

                    # Calcular intersecci√≥n
                    intersect_area = fusion_geom.intersection(geom_feature).area() or 0
                    area_hijo = geom_feature.area() or 0

                    # Validar intersecci√≥n adecuada
                    if (
                        str(self.dataET["tramite"]["subtipo"]) not in ['Prescripci√≥n parcial sobre mas de una parcela']
                        and tramite_objeto not in excepciones_tramite[0:2] and tramite_objeto not in ['Mensura para reputacion de dominio', 'Mensura para reputacion de dominio y divisi√≥n']
                    ):
                        if intersect_area < T_2 or (area_hijo > 0 and intersect_area / area_hijo < 0.95):
                            errores_verificacion.append(
                                "El objeto geom√©trico seleccionado no intersecta adecuadamente con la geometr√≠a origen"
                            )

                    # Validar superposici√≥n (para tr√°mites espec√≠ficos)
                    if tramite_objeto in ['Adjudicaci√≥n de partida inmobiliaria', 'Desglose', 'Mensura para reputacion de dominio', 'Mensura para reputacion de dominio y divisi√≥n']:
                        if intersect_area > T_2:
                            errores_verificacion.append(
                                "El objeto geom√©trico seleccionado (hijo) se superpone al objeto origen. "
                                "En este tipo de tr√°mite, el hijo no debe ocupar ninguna parte de la parcela origen com√∫n."
                            )
            except Exception as e:
                error_inesperado()
                
            
            # ========== C√ÅLCULO DE SUPERFICIES SIMPLIFICADO ==========
            # Determinar si es el padre (superficie m√°xima)
            try:
                superficie_maxima = max(float(e['superficie']) for e in self.dataET["entradas"] if 'superficie' in e)
                es_padre = float(item['superficie']) == superficie_maxima
            except (ValueError, KeyError):
                es_padre = False
            except Exception as e:
                error_inesperado()
                
            
            # C√°lculo simplificado de superficies
            try:
                superficie_hijas = float(self.dataET.get("superficie_hijas", 0)) - float(item.get('superficie', 0))
                superficie_espacio_publico = float(self.dataET.get('superficies_espacio_publico', 0))
                
                # C√°lculo de remanente simplificado
                remanente = float(item.get('superficie', 0)) - superficie_hijas - superficie_espacio_publico if es_padre else 0.0
            except Exception as e:
                error_inesperado()
                

            tiene_mismo_id = item.get("id_padre") and item["id"] == item["id_padre"]

            # ========== VALIDACI√ìN SUPERPOSICI√ìN MEJORADA ==========
            # SOLO se realiza si se pueden identificar claramente las parcelas origen
            try:
                if tramite_objeto not in ['Adjudicaci√≥n de partida inmobiliaria', 'Desglose'] and tramite_objeto in prescripciones_multiples:              
                    if layer_parcelas:
                        search_rect = geom_feature.boundingBox()
                        
                        # Variables para acumular superposiciones
                        total_intersect_area_parcelas = 0.0
                        parcelas_superpuestas_detalle = []

                        # Para evitar duplicar una misma parcela
                        parcelas_vistas = set()
                        
                        # M√âTODO MEJORADO: Buscar parcelas origen usando m√∫ltiples estrategias
                        adremas_origen = []
                        featids_origen = []
                        parcelas_origen_encontradas = False
                        
                        # INICIALIZAR geom_origen_list al principio
                        geom_origen_list = []
                        
                        # Estrategia 1: Buscar en las entradas del tr√°mite por anidaci√≥n
                        for entrada in self.dataET["entradas"]:
                            if entrada.get("anidacion") == 0:  # Es parcela padre/origen
                                if 'adrema' in entrada and entrada['adrema'] not in [None, ""]:
                                    adremas_origen.append(str(entrada['adrema']))
                                    parcelas_origen_encontradas = True
                                elif 'partida_inmobiliaria' in entrada and entrada['partida_inmobiliaria']:
                                    partida = entrada['partida_inmobiliaria']
                                    if ':' in partida:
                                        adrema = partida.split(':')[-1].strip()
                                        if adrema not in [None, ""]:
                                            adremas_origen.append(adrema)
                                            parcelas_origen_encontradas = True
                                
                                # Agregar featid si existe - CONVERSI√ìN MEJORADA
                                if 'featid' in entrada and entrada['featid'] not in [None, ""]:
                                    featid_str = str(int(entrada['featid'])) if entrada['featid'] == int(entrada['featid']) else str(entrada['featid'])
                                    featids_origen.append(featid_str)
                                    parcelas_origen_encontradas = True
                        
                        # Estrategia 2: Buscar por ID del padre
                        if not parcelas_origen_encontradas and 'id_padre' in item and item['id_padre']:
                            padre_id = item['id_padre']
                            for entrada in self.dataET["entradas"]:
                                if entrada.get("id") == padre_id:
                                    if 'adrema' in entrada and entrada['adrema'] not in [None, ""]:
                                        adremas_origen.append(str(entrada['adrema']))
                                        parcelas_origen_encontradas = True
                                    elif 'partida_inmobiliaria' in entrada and entrada['partida_inmobiliaria']:
                                        partida = entrada['partida_inmobiliaria']
                                        if ':' in partida:
                                            adrema = partida.split(':')[-1].strip()
                                            if adrema not in [None, ""]:
                                                adremas_origen.append(adrema)
                                                parcelas_origen_encontradas = True

                                    if 'featid' in entrada and entrada['featid'] not in [None, ""]:
                                        featid_str = str(int(entrada['featid'])) if entrada['featid'] == int(entrada['featid']) else str(entrada['featid'])
                                        featids_origen.append(featid_str)
                                        parcelas_origen_encontradas = True
                                    break
                        
                        # Estrategia 3: Buscar en capa temporal por ID del padre
                        if not parcelas_origen_encontradas and 'id_padre' in item and item['id_padre']:
                            if layer_padre:
                                expr = QgsExpression(f"\"id\" = {item['id_padre']}")
                                request = QgsFeatureRequest(expr)
                                features_padre = list(layer_padre.getFeatures(request))
                                if features_padre:
                                    for f in features_padre:
                                        if 'adrema' in f.fields().names() and f['adrema'] not in [None, ""]:
                                            adremas_origen.append(str(f['adrema']))
                                            parcelas_origen_encontradas = True
                                        if 'featid' in f.fields().names() and f['featid'] not in [None, ""]:
                                            featid_str = str(int(f['featid'])) if f['featid'] == int(f['featid']) else str(f['featid'])
                                            featids_origen.append(featid_str)
                                            parcelas_origen_encontradas = True
                        
                        # **INCLUIR PARCELA ACTUAL COMO ORIGEN**
                        if 'featid' in item and item['featid'] not in [None, ""]:
                            featid_actual = str(int(item['featid'])) if item['featid'] == int(item['featid']) else str(item['featid'])
                            if featid_actual not in featids_origen:
                                featids_origen.append(featid_actual)
                                print(f"‚úÖ Agregada parcela actual como origen: {featid_actual}")

                        print(f"üîç Adremas de origen encontradas: {adremas_origen}")
                        print(f"üîç Featids de origen encontrados: {featids_origen}")
                        print(f"üîç Parcelas origen encontradas: {parcelas_origen_encontradas}")
                        
                        # PRIMERA PASADA: Recolectar geometr√≠as de parcelas origen
                        for layer in layer_parcelas:
                            request = QgsFeatureRequest().setFilterRect(search_rect)
                            
                            for f in layer.getFeatures(request):
                                geom_parcela = f.geometry()
                                featid_parcela = f.attribute('featid')
                                adrema_parcela = f.attribute('adrema')

                                # Determinar si es parcela origen - CONVERSI√ìN MEJORADA
                                es_parcela_origen = False
                                if featid_parcela:
                                    # Convertir a string y eliminar .0 si existe
                                    featid_parcela_str = str(int(featid_parcela)) if featid_parcela == int(featid_parcela) else str(featid_parcela)
                                    if featid_parcela_str in featids_origen:
                                        es_parcela_origen = True
                                if not es_parcela_origen and adrema_parcela and str(adrema_parcela) in adremas_origen:
                                    es_parcela_origen = True

                                # Recolectar geometr√≠as origen - CORRECCI√ìN: usar QgsGeometry() en lugar de clone()
                                if es_parcela_origen:
                                    geom_origen_list.append(QgsGeometry(geom_parcela))  # CORREGIDO
                                    print(f"‚úÖ Geometr√≠a origen recolectada: {featid_parcela} - {adrema_parcela}")

                        print(f"üîç Total geometr√≠as origen recolectadas: {len(geom_origen_list)}")

                        # ESTRATEGIA 4: BUSCAR EN LAS CAPAS DE PARCELAS PARA IDENTIFICAR OR√çGENES POR RELACI√ìN ESPACIAL
                        # Solo si tenemos geometr√≠as origen recolectadas
                        if geom_origen_list and len(geom_origen_list) > 0:
                            # Crear geometr√≠a fusionada de todos los or√≠genes identificados
                            if len(geom_origen_list) == 1:
                                geometria_fusionada_origen = geom_origen_list[0]
                            else:
                                geometria_fusionada_origen = geom_origen_list[0]
                                for geom in geom_origen_list[1:]:
                                    geometria_fusionada_origen = geometria_fusionada_origen.combine(geom)
                            
                            print(f"üîç Geometr√≠a fusionada origen - √°rea: {geometria_fusionada_origen.area()}m¬≤")
                            
                            # Buscar parcelas que intersectan con la geometr√≠a fusionada de or√≠genes
                            for layer in layer_parcelas:
                                request = QgsFeatureRequest().setFilterRect(geometria_fusionada_origen.boundingBox())
                                for f in layer.getFeatures(request):
                                    if geometria_fusionada_origen.intersects(f.geometry()):
                                        featid_parcela = f.attribute('featid')
                                        adrema_parcela = f.attribute('adrema')
                                        
                                        if featid_parcela:
                                            featid_parcela_str = str(int(featid_parcela)) if featid_parcela == int(featid_parcela) else str(featid_parcela)
                                            if featid_parcela_str not in featids_origen:
                                                featids_origen.append(featid_parcela_str)
                                                print(f"‚úÖ Estrategia 4 - Featid origen por relaci√≥n espacial: {featid_parcela_str}")
                                        
                                        if adrema_parcela and str(adrema_parcela) not in adremas_origen:
                                            adremas_origen.append(str(adrema_parcela))
                                            print(f"‚úÖ Estrategia 4 - Adrema origen por relaci√≥n espacial: {adrema_parcela}")

                        # SEGUNDA PASADA: Detecci√≥n de superposiciones con parcelas NO origen
                        bandera_superposicion_origen = False
                        bandera_coincidencia_exacta = False
                        
                        print(f"üîç Iniciando segunda pasada - B√∫squeda en {len(layer_parcelas)} capas")
                        
                        for layer in layer_parcelas:
                            request = QgsFeatureRequest().setFilterRect(search_rect)
                            features_count = 0
                            intersect_count = 0
                            
                            for f in layer.getFeatures(request):
                                features_count += 1
                                geom_parcela = f.geometry()
                                featid_parcela = f.attribute('featid')
                                adrema_parcela = f.attribute('adrema')

                                # Determinar si es parcela origen - CONVERSI√ìN MEJORADA
                                es_parcela_origen = False
                                if featid_parcela:
                                    # Convertir a string y eliminar .0 si existe
                                    featid_parcela_str = str(int(featid_parcela)) if featid_parcela == int(featid_parcela) else str(featid_parcela)
                                    if featid_parcela_str in featids_origen:
                                        es_parcela_origen = True
                                if not es_parcela_origen and adrema_parcela and str(adrema_parcela) in adremas_origen:
                                    es_parcela_origen = True

                                # ESTRATEGIA 5: COMPARACI√ìN GEOM√âTRICA DIRECTA CON PARCELAS ORIGEN
                                if not es_parcela_origen and geom_origen_list:
                                    for geom_origen in geom_origen_list:
                                        if geom_parcela.equals(geom_origen):
                                            es_parcela_origen = True
                                            print(f"‚úÖ Identificada como origen por igualdad geom√©trica: {featid_parcela} - {adrema_parcela}")
                                            # Agregar a las listas de origen para futuras comparaciones
                                            if featid_parcela:
                                                featid_str = str(int(featid_parcela)) if featid_parcela == int(featid_parcela) else str(featid_parcela)
                                                if featid_str not in featids_origen:
                                                    featids_origen.append(featid_str)
                                            if adrema_parcela and str(adrema_parcela) not in adremas_origen:
                                                adremas_origen.append(str(adrema_parcela))
                                            break

                                # Coincidencia exacta individual
                                if es_parcela_origen and geom_parcela.equals(geom_feature):
                                    bandera_coincidencia_exacta = True
                                    print(f"üéØ COINCIDENCIA EXACTA con parcela origen: {featid_parcela} - {adrema_parcela}")
                                
                                # Caso A: superposici√≥n indebida con origen
                                if item["anidacion"] == 1 and es_parcela_origen and item["id"] != str(int(featid_parcela)):
                                    bandera_superposicion_origen = True
                                    print(f"üö® POSIBLE ERROR: Superposici√≥n con parcela origen - {featid_parcela} vs item {item['id']}")
                                
                                # Caso B: origen v√°lido ‚Üí se salta
                                if es_parcela_origen:
                                    print(f"‚úÖ Saltando parcela origen v√°lida: {featid_parcela} - {adrema_parcela}")
                                    continue
                                
                                # Caso C: no es origen ‚Üí validar intersecci√≥n
                                if geom_feature.intersects(geom_parcela):
                                    intersect_count += 1

                                    # Correcci√≥n de duplicados
                                    clave = str(featid_parcela) if featid_parcela else str(adrema_parcela)
                                    if clave in parcelas_vistas:
                                        continue
                                    parcelas_vistas.add(clave)

                                    inter = geom_feature.intersection(geom_parcela)
                                    area = inter.area()
                                    nombre = f.attribute('adrema') or f.attribute('partida') or f"FeatID: {featid_parcela}"
                                    if area > T_2:
                                        total_intersect_area_parcelas += area
                                        parcelas_superpuestas_detalle.append({
                                            'nombre': nombre,
                                            'area': area,
                                            'featid': featid_parcela,
                                            'adrema': adrema_parcela
                                        })
                                        print(f"üîç Superposici√≥n detectada con: {nombre} (√°rea: {area}m¬≤) - FeatID: {featid_parcela}")
                                    else:
                                        print(f"üîç Intersecci√≥n con {nombre} pero √°rea ({area}m¬≤) menor a tolerancia ({T_2}m¬≤)")
                                else:
                                    # Solo para diagn√≥stico: verificar si hay casi intersecci√≥n
                                    distancia = geom_feature.distance(geom_parcela)
                                    if distancia < 1.0:  # Menos de 1 metro de distancia
                                        print(f"üîç Parcela cercana (distancia: {distancia}m): {featid_parcela} - {adrema_parcela}")
                            
                            print(f"üîç Capa {layer.name()}: {features_count} features examinados, {intersect_count} intersecciones encontradas")

                        print(f"üîç √Årea de intersecci√≥n total: {total_intersect_area_parcelas}m¬≤ (m√≠nimo {T_2}m¬≤)")
                        print(f"üîç N√∫mero de parcelas superpuestas detectadas: {len(parcelas_superpuestas_detalle)}")
                        
                        # -------------------------------------------------------------
                        # VALIDACI√ìN POR √ÅREA (no solo igualdad geom√©trica)
                        # -------------------------------------------------------------
                        area_destino = geom_feature.area()
                        area_diff = abs(total_intersect_area_parcelas - area_destino)

                        if area_diff < 0.5 and tramite_objeto not in ['Mensura para reputacion de dominio', 'Mensura para reputacion de dominio y divisi√≥n'] and padre_geom:  # Ajustable
                            print("üü¢ AREA MATCH: La suma de √°reas intersectadas coincide con el destino ‚Üí se marcan como ORIGEN")
                            for s in parcelas_superpuestas_detalle:
                                if s['featid']:
                                    featid_str = str(int(s['featid'])) if s['featid'] == int(s['featid']) else str(s['featid'])
                                    if featid_str not in featids_origen:
                                        featids_origen.append(featid_str)
                                        print(f"‚úÖ Agregado como origen por √°rea match: {featid_str}")
                            total_intersect_area_parcelas = 0
                            parcelas_superpuestas_detalle.clear()

                        # -------------------------------------------------------------
                        # VALIDACI√ìN FINAL DE SUPERPOSICIONES - EXCLUYENDO OR√çGENES
                        # -------------------------------------------------------------
                        if total_intersect_area_parcelas > T_2 or bandera_fuera_contencion:
                            # Filtrar SOLO las parcelas que NO son origen
                            parcelas_no_origen = []
                            total_area_no_origen = 0.0
                            
                            print("üîç Iniciando filtrado de parcelas NO origen...")
                            for s in parcelas_superpuestas_detalle:
                                # Verificar tanto por featid como por adrema - CONVERSI√ìN MEJORADA
                                es_origen_por_featid = False
                                if s['featid']:
                                    # Convertir featid a string compatible
                                    featid_s = str(int(s['featid'])) if s['featid'] == int(s['featid']) else str(s['featid'])
                                    es_origen_por_featid = featid_s in featids_origen
                                
                                es_origen_por_adrema = str(s['adrema']) in adremas_origen if s['adrema'] else False
                                
                                print(f"üîç Validando parcela {s['nombre']} - FeatID: {s['featid']} (como string: {featid_s if s['featid'] else 'N/A'}) - Adrema: {s['adrema']}")
                                print(f"   Es origen por featid: {es_origen_por_featid}")
                                print(f"   Es origen por adrema: {es_origen_por_adrema}")
                                print(f"   Featids origen disponibles: {featids_origen}")
                                print(f"   Adremas origen disponibles: {adremas_origen}")
                                
                                if not es_origen_por_featid and not es_origen_por_adrema:
                                    parcelas_no_origen.append(s)
                                    total_area_no_origen += s['area']
                                    print(f"   ‚ùå INCLUIDA en validaci√≥n (NO es origen)")
                                else:
                                    print(f"   ‚úÖ EXCLUIDA de validaci√≥n (ES origen)")
                            
                            print(f"üîç Total parcelas NO origen: {len(parcelas_no_origen)}")
                            print(f"üîç √Årea total de superposici√≥n con NO origen: {total_area_no_origen}m¬≤")
                            
                            # Si todas las parcelas superpuestas son origen ‚Üí permitir
                            if len(parcelas_no_origen) == 0:
                                print("‚úÖ SUPERPOSICI√ìN PERMITIDA: Todas las parcelas intersectadas son origen del tr√°mite")
                                total_intersect_area_parcelas = 0
                                parcelas_superpuestas_detalle.clear()
                            
                            # Si hay superposici√≥n con parcelas NO origen
                            elif total_area_no_origen > T_2 or bandera_fuera_contencion:
                                detalle = "\n".join([
                                    f"   - {p['nombre']}: {'%.10f' % p['area']}m¬≤" 
                                    for p in parcelas_no_origen
                                ])
                                
                                # Mantengo tu diferenciaci√≥n EXACTA
                                if bandera_superposicion_origen:
                                    errores_verificacion.append(
                                        f"El objeto geom√©trico seleccionado se superpone a parcelas que deber√≠an ser la origen del tr√°mite. Verificar.\n"
                                        f"Suma total de superficies superpuestas: {'%.10f' % total_area_no_origen}m¬≤\n"
                                        f"Tolerancia conforme a Art.148 Ley 2283/68: {'%.10f' % T_2}m¬≤\n"
                                        f"Detalle por parcela intersectada:\n{detalle}"
                                    )
                                else:
                                    # NUEVO: Mostrar di√°logo de confirmaci√≥n para superposici√≥n con parcelas NO origen
                                    mensaje_advertencia = (
                                        f"El objeto geom√©trico seleccionado se superpone a parcelas a las que NO deber√≠a superponerse seg√∫n tr√°mite.\n"
                                        f"Tolerancia conforme a Art.148 Ley 2283/68: {'%.10f' % T_2}m¬≤\n"
                                        f"Suma total de superficies superpuestas: {'%.10f' % total_area_no_origen}m¬≤\n"
                                        f"Detalle por parcela intersectada:\n{detalle}"
                                    )
                                    
                                    confirmacion = QMessageBox(QMessageBox.Question,
                                                            "Confirmaci√≥n de Superposici√≥n",
                                                            f"{mensaje_advertencia}\n\n¬øContinuar con la asociaci√≥n?",
                                                            QMessageBox.Yes | QMessageBox.No,
                                                            self.dlgET)
                                    confirmacion.buttons()[0].setText("S√≠")
                                    confirmacion.buttons()[1].setText("No")
                                    respuesta = confirmacion.exec()
                                    
                                    if respuesta == QMessageBox.No:
                                        errores_verificacion.append(mensaje_advertencia)
                                    else:
                                        print("‚úÖ Usuario confirm√≥ continuar a pesar de la superposici√≥n con parcelas no origen")
                            else:
                                print("‚úÖ Superposici√≥n permitida: las superposiciones son solo con parcelas origen o est√°n dentro de la tolerancia")

                        else:
                            print("‚úÖ No se detectaron superposiciones con parcelas no-origen")

                    else:
                        print("‚ö†Ô∏è No se pudieron identificar claramente las parcelas origen. Se omite la validaci√≥n de superposici√≥n por seguridad.")
                else:
                    if layer_parcelas:
                        search_rect = geom_feature.boundingBox()
                        
                        # Variables para acumular superposiciones
                        total_intersect_area_parcelas = 0.0
                        parcelas_superpuestas_detalle = []

                        # Para evitar duplicar una misma parcela
                        parcelas_vistas = set()
                        
                        # M√âTODO MEJORADO: Buscar parcelas origen usando m√∫ltiples estrategias
                        adremas_origen = []
                        featids_origen = []
                        parcelas_origen_encontradas = False
                        
                        # INICIALIZAR geom_origen_list al principio
                        geom_origen_list = []
                        
                        # Estrategia 1: Buscar en las entradas del tr√°mite por anidaci√≥n
                        for entrada in self.dataET["entradas"]:
                            if entrada.get("anidacion") == 0:  # Es parcela padre/origen
                                if 'adrema' in entrada and entrada['adrema'] not in [None, ""]:
                                    adremas_origen.append(str(entrada['adrema']))
                                    parcelas_origen_encontradas = True
                                elif 'partida_inmobiliaria' in entrada and entrada['partida_inmobiliaria']:
                                    partida = entrada['partida_inmobiliaria']
                                    if ':' in partida:
                                        adrema = partida.split(':')[-1].strip()
                                        if adrema not in [None, ""]:
                                            adremas_origen.append(adrema)
                                            parcelas_origen_encontradas = True
                                
                                # Agregar featid si existe - CONVERSI√ìN MEJORADA
                                if 'featid' in entrada and entrada['featid'] not in [None, ""]:
                                    featid_str = str(int(entrada['featid'])) if entrada['featid'] == int(entrada['featid']) else str(entrada['featid'])
                                    featids_origen.append(featid_str)
                                    parcelas_origen_encontradas = True
                        
                        # Estrategia 2: Buscar por ID del padre
                        if not parcelas_origen_encontradas and 'id_padre' in item and item['id_padre']:
                            padre_id = item['id_padre']
                            for entrada in self.dataET["entradas"]:
                                if entrada.get("id") == padre_id:
                                    if 'adrema' in entrada and entrada['adrema'] not in [None, ""]:
                                        adremas_origen.append(str(entrada['adrema']))
                                        parcelas_origen_encontradas = True
                                    elif 'partida_inmobiliaria' in entrada and entrada['partida_inmobiliaria']:
                                        partida = entrada['partida_inmobiliaria']
                                        if ':' in partida:
                                            adrema = partida.split(':')[-1].strip()
                                            if adrema not in [None, ""]:
                                                adremas_origen.append(adrema)
                                                parcelas_origen_encontradas = True

                                    if 'featid' in entrada and entrada['featid'] not in [None, ""]:
                                        featid_str = str(int(entrada['featid'])) if entrada['featid'] == int(entrada['featid']) else str(entrada['featid'])
                                        featids_origen.append(featid_str)
                                        parcelas_origen_encontradas = True
                                    break
                        
                        # Estrategia 3: Buscar en capa temporal por ID del padre
                        if not parcelas_origen_encontradas and 'id_padre' in item and item['id_padre']:
                            if layer_padre:
                                expr = QgsExpression(f"\"id\" = {item['id_padre']}")
                                request = QgsFeatureRequest(expr)
                                features_padre = list(layer_padre.getFeatures(request))
                                if features_padre:
                                    for f in features_padre:
                                        if 'adrema' in f.fields().names() and f['adrema'] not in [None, ""]:
                                            adremas_origen.append(str(f['adrema']))
                                            parcelas_origen_encontradas = True
                                        if 'featid' in f.fields().names() and f['featid'] not in [None, ""]:
                                            featid_str = str(int(f['featid'])) if f['featid'] == int(f['featid']) else str(f['featid'])
                                            featids_origen.append(featid_str)
                                            parcelas_origen_encontradas = True
                        
                        # **INCLUIR PARCELA ACTUAL COMO ORIGEN**
                        if 'featid' in item and item['featid'] not in [None, ""]:
                            featid_actual = str(int(item['featid'])) if item['featid'] == int(item['featid']) else str(item['featid'])
                            if featid_actual not in featids_origen:
                                featids_origen.append(featid_actual)
                                print(f"‚úÖ Agregada parcela actual como origen: {featid_actual}")

                        print(f"üîç Adremas de origen encontradas: {adremas_origen}")
                        print(f"üîç Featids de origen encontrados: {featids_origen}")
                        print(f"üîç Parcelas origen encontradas: {parcelas_origen_encontradas}")
                        
                        # PRIMERA PASADA: Recolectar geometr√≠as de parcelas origen
                        for layer in layer_parcelas:
                            request = QgsFeatureRequest().setFilterRect(search_rect)
                            
                            for f in layer.getFeatures(request):
                                geom_parcela = f.geometry()
                                featid_parcela = f.attribute('featid')
                                adrema_parcela = f.attribute('adrema')

                                # Determinar si es parcela origen - CONVERSI√ìN MEJORADA
                                es_parcela_origen = False
                                if featid_parcela:
                                    # Convertir a string y eliminar .0 si existe
                                    featid_parcela_str = str(int(featid_parcela)) if featid_parcela == int(featid_parcela) else str(featid_parcela)
                                    if featid_parcela_str in featids_origen:
                                        es_parcela_origen = True
                                if not es_parcela_origen and adrema_parcela and str(adrema_parcela) in adremas_origen:
                                    es_parcela_origen = True

                                # Recolectar geometr√≠as origen - CORRECCI√ìN: usar QgsGeometry() en lugar de clone()
                                if es_parcela_origen:
                                    geom_origen_list.append(QgsGeometry(geom_parcela))  # CORREGIDO
                                    print(f"‚úÖ Geometr√≠a origen recolectada: {featid_parcela} - {adrema_parcela}")

                        print(f"üîç Total geometr√≠as origen recolectadas: {len(geom_origen_list)}")

                        # ESTRATEGIA 4: BUSCAR EN LAS CAPAS DE PARCELAS PARA IDENTIFICAR OR√çGENES POR RELACI√ìN ESPACIAL
                        # SOLO para tr√°mites de prescripci√≥n m√∫ltiple
                        if tramite_objeto in prescripciones_multiples and geom_origen_list and len(geom_origen_list) > 0:
                            # Crear geometr√≠a fusionada de todos los or√≠genes identificados
                            if len(geom_origen_list) == 1:
                                geometria_fusionada_origen = geom_origen_list[0]
                            else:
                                geometria_fusionada_origen = geom_origen_list[0]
                                for geom in geom_origen_list[1:]:
                                    geometria_fusionada_origen = geometria_fusionada_origen.combine(geom)
                            
                            print(f"üîç Geometr√≠a fusionada origen - √°rea: {geometria_fusionada_origen.area()}m¬≤")
                            
                            # Buscar parcelas que intersectan con la geometr√≠a fusionada de or√≠genes
                            for layer in layer_parcelas:
                                request = QgsFeatureRequest().setFilterRect(geometria_fusionada_origen.boundingBox())
                                for f in layer.getFeatures(request):
                                    if geometria_fusionada_origen.intersects(f.geometry()):
                                        featid_parcela = f.attribute('featid')
                                        adrema_parcela = f.attribute('adrema')
                                        
                                        if featid_parcela:
                                            featid_parcela_str = str(int(featid_parcela)) if featid_parcela == int(featid_parcela) else str(featid_parcela)
                                            if featid_parcela_str not in featids_origen:
                                                featids_origen.append(featid_parcela_str)
                                                print(f"‚úÖ Estrategia 4 - Featid origen por relaci√≥n espacial: {featid_parcela_str}")
                                        
                                        if adrema_parcela and str(adrema_parcela) not in adremas_origen:
                                            adremas_origen.append(str(adrema_parcela))
                                            print(f"‚úÖ Estrategia 4 - Adrema origen por relaci√≥n espacial: {adrema_parcela}")
                        else:
                            print("‚ö†Ô∏è Estrategia 4 desactivada: no es un tr√°mite de prescripci√≥n m√∫ltiple")

                        # SEGUNDA PASADA: Detecci√≥n de superposiciones con parcelas NO origen
                        bandera_superposicion_origen = False
                        bandera_coincidencia_exacta = False
                        
                        print(f"üîç Iniciando segunda pasada - B√∫squeda en {len(layer_parcelas)} capas")
                        
                        for layer in layer_parcelas:
                            request = QgsFeatureRequest().setFilterRect(search_rect)
                            features_count = 0
                            intersect_count = 0
                            
                            for f in layer.getFeatures(request):
                                features_count += 1
                                geom_parcela = f.geometry()
                                featid_parcela = f.attribute('featid')
                                adrema_parcela = f.attribute('adrema')

                                # Determinar si es parcela origen - CONVERSI√ìN MEJORADA
                                es_parcela_origen = False
                                if featid_parcela:
                                    # Convertir a string y eliminar .0 si existe
                                    featid_parcela_str = str(int(featid_parcela)) if featid_parcela == int(featid_parcela) else str(featid_parcela)
                                    if featid_parcela_str in featids_origen:
                                        es_parcela_origen = True
                                if not es_parcela_origen and adrema_parcela and str(adrema_parcela) in adremas_origen:
                                    es_parcela_origen = True

                                # ESTRATEGIA 5: COMPARACI√ìN GEOM√âTRICA DIRECTA CON PARCELAS ORIGEN
                                if not es_parcela_origen and geom_origen_list and tramite_objeto in prescripciones_multiples:
                                    for geom_origen in geom_origen_list:
                                        if geom_parcela.equals(geom_origen):
                                            es_parcela_origen = True
                                            print(f"‚úÖ Identificada como origen por igualdad geom√©trica: {featid_parcela} - {adrema_parcela}")
                                            # Agregar a las listas de origen para futuras comparaciones
                                            if featid_parcela:
                                                featid_str = str(int(featid_parcela)) if featid_parcela == int(featid_parcela) else str(featid_parcela)
                                                if featid_str not in featids_origen:
                                                    featids_origen.append(featid_str)
                                            if adrema_parcela and str(adrema_parcela) not in adremas_origen:
                                                adremas_origen.append(str(adrema_parcela))
                                            break

                                # Coincidencia exacta individual
                                if es_parcela_origen and geom_parcela.equals(geom_feature):
                                    bandera_coincidencia_exacta = True
                                    print(f"üéØ COINCIDENCIA EXACTA con parcela origen: {featid_parcela} - {adrema_parcela}")
                                
                                # Caso A: superposici√≥n indebida con origen
                                if item["anidacion"] == 1 and es_parcela_origen and item["id"] != str(int(featid_parcela)):
                                    bandera_superposicion_origen = True
                                    print(f"üö® POSIBLE ERROR: Superposici√≥n con parcela origen - {featid_parcela} vs item {item['id']}")
                                
                                # Caso B: origen v√°lido ‚Üí se salta
                                if es_parcela_origen:
                                    print(f"‚úÖ Saltando parcela origen v√°lida: {featid_parcela} - {adrema_parcela}")
                                    continue
                                
                                # Caso C: no es origen ‚Üí validar intersecci√≥n
                                if geom_feature.intersects(geom_parcela):
                                    intersect_count += 1

                                    # Correcci√≥n de duplicados
                                    clave = str(featid_parcela) if featid_parcela else str(adrema_parcela)
                                    if clave in parcelas_vistas:
                                        continue
                                    parcelas_vistas.add(clave)

                                    inter = geom_feature.intersection(geom_parcela)
                                    area = inter.area()
                                    nombre = f.attribute('adrema') or f.attribute('partida') or f"FeatID: {featid_parcela}"
                                    if area > T_2:
                                        total_intersect_area_parcelas += area
                                        parcelas_superpuestas_detalle.append({
                                            'nombre': nombre,
                                            'area': area,
                                            'featid': featid_parcela,
                                            'adrema': adrema_parcela
                                        })
                                        print(f"üîç Superposici√≥n detectada con: {nombre} (√°rea: {area}m¬≤) - FeatID: {featid_parcela}")
                                    else:
                                        print(f"üîç Intersecci√≥n con {nombre} pero √°rea ({area}m¬≤) menor a tolerancia ({T_2}m¬≤)")
                                else:
                                    # Solo para diagn√≥stico: verificar si hay casi intersecci√≥n
                                    distancia = geom_feature.distance(geom_parcela)
                                    if distancia < 1.0:  # Menos de 1 metro de distancia
                                        print(f"üîç Parcela cercana (distancia: {distancia}m): {featid_parcela} - {adrema_parcela}")
                            
                            print(f"üîç Capa {layer.name()}: {features_count} features examinados, {intersect_count} intersecciones encontradas")

                        print(f"üîç √Årea de intersecci√≥n total: {total_intersect_area_parcelas}m¬≤ (m√≠nimo {T_2}m¬≤)")
                        print(f"üîç N√∫mero de parcelas superpuestas detectadas: {len(parcelas_superpuestas_detalle)}")
                        
                        # -------------------------------------------------------------
                        # VALIDACI√ìN POR √ÅREA (no solo igualdad geom√©trica)
                        # -------------------------------------------------------------
                        area_destino = geom_feature.area()
                        area_diff = abs(total_intersect_area_parcelas - area_destino)

                        if area_diff < 0.5 and tramite_objeto not in ['Mensura para reputacion de dominio', 'Mensura para reputacion de dominio y divisi√≥n'] and padre_geom:  # Ajustable
                            print("üü¢ AREA MATCH: La suma de √°reas intersectadas coincide con el destino ‚Üí se marcan como ORIGEN")
                            for s in parcelas_superpuestas_detalle:
                                if s['featid']:
                                    featid_str = str(int(s['featid'])) if s['featid'] == int(s['featid']) else str(s['featid'])
                                    if featid_str not in featids_origen:
                                        featids_origen.append(featid_str)
                                        print(f"‚úÖ Agregado como origen por √°rea match: {featid_str}")
                            total_intersect_area_parcelas = 0
                            parcelas_superpuestas_detalle.clear()

                        # -------------------------------------------------------------
                        # VALIDACI√ìN FINAL DE SUPERPOSICIONES - EXCLUYENDO OR√çGENES
                        # -------------------------------------------------------------
                        if total_intersect_area_parcelas > T_2 or bandera_fuera_contencion:
                            # Filtrar SOLO las parcelas que NO son origen
                            parcelas_no_origen = []
                            total_area_no_origen = 0.0
                            
                            print("üîç Iniciando filtrado de parcelas NO origen...")
                            for s in parcelas_superpuestas_detalle:
                                # Verificar tanto por featid como por adrema - CONVERSI√ìN MEJORADA
                                es_origen_por_featid = False
                                if s['featid']:
                                    # Convertir featid a string compatible
                                    featid_s = str(int(s['featid'])) if s['featid'] == int(s['featid']) else str(s['featid'])
                                    es_origen_por_featid = featid_s in featids_origen
                                
                                es_origen_por_adrema = str(s['adrema']) in adremas_origen if s['adrema'] else False
                                
                                print(f"üîç Validando parcela {s['nombre']} - FeatID: {s['featid']} (como string: {featid_s if s['featid'] else 'N/A'}) - Adrema: {s['adrema']}")
                                print(f"   Es origen por featid: {es_origen_por_featid}")
                                print(f"   Es origen por adrema: {es_origen_por_adrema}")
                                print(f"   Featids origen disponibles: {featids_origen}")
                                print(f"   Adremas origen disponibles: {adremas_origen}")
                                
                                if not es_origen_por_featid and not es_origen_por_adrema:
                                    parcelas_no_origen.append(s)
                                    total_area_no_origen += s['area']
                                    print(f"   ‚ùå INCLUIDA en validaci√≥n (NO es origen)")
                                else:
                                    print(f"   ‚úÖ EXCLUIDA de validaci√≥n (ES origen)")
                            
                            print(f"üîç Total parcelas NO origen: {len(parcelas_no_origen)}")
                            print(f"üîç √Årea total de superposici√≥n con NO origen: {total_area_no_origen}m¬≤")
                            
                            # Si todas las parcelas superpuestas son origen ‚Üí permitir
                            if len(parcelas_no_origen) == 0:
                                print("‚úÖ SUPERPOSICI√ìN PERMITIDA: Todas las parcelas intersectadas son origen del tr√°mite")
                                total_intersect_area_parcelas = 0
                                parcelas_superpuestas_detalle.clear()
                            
                            # Si hay superposici√≥n con parcelas NO origen ‚Üí ERROR DIRECTO SIN CONFIRMACI√ìN
                            elif total_area_no_origen > T_2 or bandera_fuera_contencion:
                                detalle = "\n".join([
                                    f"   - {p['nombre']}: {'%.10f' % p['area']}m¬≤" 
                                    for p in parcelas_no_origen
                                ])
                                
                                # ERROR DIRECTO - SIN CONFIRMACI√ìN PARA TR√ÅMITES QUE NO SON PRESCRIPCI√ìN
                                errores_verificacion.append(
                                    f"El objeto geom√©trico seleccionado se superpone a parcelas a las que NO deber√≠a superponerse seg√∫n tr√°mite.\n"
                                    f"Tolerancia conforme a Art.148 Ley 2283/68: {'%.10f' % T_2}m¬≤\n"
                                    f"Suma total de superficies superpuestas: {'%.10f' % total_area_no_origen}m¬≤\n"
                                    f"Detalle por parcela intersectada:\n{detalle}"
                                )
            except Exception as e:
                error_inesperado()
                
            # ========== VALIDACI√ìN DE CONSISTENCIA DE SUPERFICIE PARA PARCELAS ORIGEN (ASOCIADAS) ==========
            try:
                # Validar solo en las destinos y cuando el tr√°mite no sea Desglose o Adjundicaci√≥n de Partida Inmobiliaria.
                if item["anidacion"] == 1 and tramite_objeto not in excepciones_tramite[0:2]:
                    print("[DEBUG-SUP] === INICIANDO VALIDACI√ìN DE SUPERFICIES ORIGEN ===")
                    
                    # 1. Obtener tolerancia de par√°metros (porcentaje)
                    tolerancia_sup_percent = 5.0  # valor por defecto
                    if "parametros" in self.dataET and "TOLERANCIA_SUPERFICIE" in self.dataET["parametros"]:
                        try:
                            tolerancia_sup_percent = float(self.dataET["parametros"]["TOLERANCIA_SUPERFICIE"])
                        except (ValueError, TypeError):
                            tolerancia_sup_percent = 5.0
                    print(f"[DEBUG-SUP] Tolerancia de superficie configurada: {tolerancia_sup_percent}%")
                    
                    # 2. Identificar TODAS las parcelas origen del tr√°mite (nivel anidaci√≥n 0 o sin padre)
                    # Usar conjuntos para evitar duplicados por id_objeto o partida
                    parcelas_origen_ids = set()
                    parcelas_origen_partidas = set()
                    parcelas_origen_unicas = []
                    
                    print("[DEBUG-SUP] === BUSCANDO PARCELAS ORIGEN EN ENTRADAS ===")
                    for i, entrada in enumerate(self.dataET["entradas"]):
                        if entrada.get("descripcion") == "PARCELA":
                            
                            id_objeto = entrada.get("id_objeto")
                            partida = entrada.get("partida_inmobiliaria")
                            
                            # Verificar si es origen y si ya no hemos procesado esta parcela
                            if (entrada.get("anidacion", 999) == 0 or entrada.get("id_padre") is None):
                                print(f"  -> ES ORIGEN (anidacion=0 o id_padre=None)")
                                
                                # Evitar duplicados: usar id_objeto si existe, si no usar partida
                                if id_objeto and id_objeto not in parcelas_origen_ids:
                                    parcelas_origen_ids.add(id_objeto)
                                    parcelas_origen_unicas.append(entrada)
                                    print(f"  -> Agregada (por id_objeto √∫nico)")
                                elif partida and partida not in parcelas_origen_partidas:
                                    parcelas_origen_partidas.add(partida)
                                    parcelas_origen_unicas.append(entrada)
                                    print(f"  -> Agregada (por partida √∫nica)")
                                else:
                                    print(f"  -> Omitida (ya procesada)")
                    
                    print(f"[DEBUG-SUP] Se encontraron {len(parcelas_origen_unicas)} parcelas origen √∫nicas para validar")
                    
                    # CONJUNTO PARA CONTROLAR PARTIDAS QUE YA TIENEN ERROR REPORTADO
                    partidas_con_error = set()
                    
                    # 3. Para cada parcela origen √∫nica, verificar consistencia si est√° asociada
                    for parcela_origen in parcelas_origen_unicas:
                        id_objeto_origen = parcela_origen.get("id_objeto")
                        partida_origen = parcela_origen.get("partida_inmobiliaria", "N/A")
                        
                        print(f"\n[DEBUG-SUP] Procesando parcela origen √∫nica: {partida_origen} (id_objeto: {id_objeto_origen})")
                        
                        # Solo validar si la parcela origen est√° asociada
                        if parcela_origen.get("asociada"):
                            print(f"[DEBUG-SUP] Parcela origen {partida_origen} est√° marcada como asociada")
                            
                            # 3.1. CONSULTAR DIRECTAMENTE LA CAPA TEMPORAL PARA OBTENER TODAS LAS GEOMETR√çAS
                            area_grafica_total = 0.0
                            geometrias_encontradas = 0
                            
                            # Buscar la capa temporal de parcelas
                            capa_temporal = next((lay["obj"] for lay in self.layers if lay["fisico"] == "TEMPORAL:PARCELAS"), None)
                            if capa_temporal:
                                print(f"[DEBUG-SUP] Consultando capa temporal: {capa_temporal.name()}")
                                
                                # Buscar todas las features con el id_objeto
                                expr = QgsExpression(f"\"id_objeto\" = {id_objeto_origen}")
                                request = QgsFeatureRequest(expr)
                                
                                try:
                                    features = list(capa_temporal.getFeatures(request))
                                    print(f"[DEBUG-SUP] Encontradas {len(features)} features en capa temporal para id_objeto {id_objeto_origen}")
                                    
                                    for feature in features:
                                        geom = feature.geometry()
                                        if geom and geom.isGeosValid():
                                            area = geom.area()
                                            area_grafica_total += area
                                            geometrias_encontradas += 1
                                            print(f"[DEBUG-SUP]   - Geometr√≠a {geometrias_encontradas}: {area:.6f} m¬≤")
                                            
                                            # Debug: mostrar atributos de la feature
                                            print(f"[DEBUG-SUP]     Attributos: id={feature.attribute('id')}, id_objeto={feature.attribute('id_objeto')}")
                                except Exception as e:
                                    print(f"[DEBUG-SUP] ERROR al consultar features: {str(e)}")
                            else:
                                print("[DEBUG-SUP] ERROR: No se encontr√≥ la capa temporal de parcelas")
                            
                            print(f"[DEBUG-SUP] Superficie gr√°fica total para {partida_origen}: {area_grafica_total:.6f} m¬≤ (suma de {geometrias_encontradas} geometr√≠as)")
                            
                            # 3.2. Obtener superficie alfanum√©rica (usar la entrada actual)
                            superficie_alfa = 0.0
                            try:
                                # Buscar la superficie en la entrada original
                                sup_value = parcela_origen.get("superficie", 0)
                                if hasattr(sup_value, 'to_eng_string'):
                                    # Es un Decimal
                                    superficie_alfa = float(sup_value)
                                else:
                                    superficie_alfa = float(sup_value) if sup_value else 0.0
                                
                                # Aplicar conversi√≥n si es tipo 2 o 3 (hect√°reas a m¬≤)
                                id_tipo_parcela = parcela_origen.get("id_tipo_parcela") or parcela_origen.get("tipo")
                                print(f"[DEBUG-SUP] Tipo parcela: {id_tipo_parcela}")
                                if id_tipo_parcela in [2, 3, '2', '3']:
                                    superficie_alfa *= 10000
                                    print(f"[DEBUG-SUP] Conversi√≥n HA‚Üím¬≤ aplicada: {superficie_alfa:.2f} m¬≤")
                            except Exception as sup_error:
                                print(f"[DEBUG-SUP] Error al obtener superficie alfanum√©rica: {str(sup_error)}")
                                superficie_alfa = 0.0
                            
                            print(f"[DEBUG-SUP] Superficie alfanum√©rica para {partida_origen}: {superficie_alfa:.6f} m¬≤")
                            
                            # 3.3. Aplicar tolerancia y validar
                            if superficie_alfa > 0 and area_grafica_total > 0:  # Solo validar si hay ambas superficies
                                # Calcular tolerancia absoluta (porcentaje de la superficie alfanum√©rica)
                                tolerancia_absoluta = (tolerancia_sup_percent / 100.0) * superficie_alfa
                                
                                # Calcular diferencia
                                diferencia = abs(area_grafica_total - superficie_alfa)
                                porcentaje_diferencia = (diferencia / superficie_alfa) * 100 if superficie_alfa > 0 else 100
                                
                                print(f"[DEBUG-SUP] Validaci√≥n para {partida_origen}:")
                                print(f"  - √Årea gr√°fica (SUMA): {area_grafica_total:.6f} m¬≤")
                                print(f"  - √Årea alfanum√©rica: {superficie_alfa:.6f} m¬≤")
                                print(f"  - Diferencia: {diferencia:.6f} m¬≤ ({porcentaje_diferencia:.2f}%)")
                                print(f"  - Tolerancia ({tolerancia_sup_percent}%): ¬±{tolerancia_absoluta:.6f} m¬≤")
                                
                                if diferencia > tolerancia_absoluta:
                                    # Inconsistencia fuera de tolerancia
                                    print(f"[DEBUG-SUP] ERROR: Parcela origen {partida_origen} fuera de tolerancia")
                                    
                                    # VERIFICAR SI ESTA PARTIDA YA TIENE UN ERROR REPORTADO
                                    if partida_origen not in partidas_con_error:
                                        # Agregar error solo si no se ha reportado antes para esta partida
                                        errores_verificacion.append(
                                            f"INCONSISTENCIA GR√ÅFICA EN PARCELA ORIGEN (Partida: {partida_origen}):\n"
                                            f"  ‚Ä¢ Superficie alfanum√©rica: {superficie_alfa:.2f} m¬≤\n"
                                            f"  ‚Ä¢ Superficie gr√°fica: {area_grafica_total:.2f} m¬≤\n"
                                            f"  ‚Ä¢ Diferencia: {diferencia:.2f} m¬≤ ({porcentaje_diferencia:.1f}%)\n"
                                            f"  ‚Ä¢ Tolerancia permitida ({tolerancia_sup_percent}%): ¬±{tolerancia_absoluta:.2f} m¬≤\n"
                                            f"\n"
                                            f"La parcela origen debe tener su superficie gr√°fica consistente "
                                            f"con la alfanum√©rica antes de asociar nuevas parcelas destino."
                                        )
                                        # Registrar que esta partida ya tiene un error
                                        partidas_con_error.add(partida_origen)
                                        print(f"[DEBUG-SUP] Error agregado para partida {partida_origen}")
                                    else:
                                        print(f"[DEBUG-SUP] Error ya reportado anteriormente para partida {partida_origen}, omitiendo")
                                else:
                                    print(f"[DEBUG-SUP] ‚úì Parcela origen {partida_origen} OK: dentro de tolerancia")
                            elif area_grafica_total == 0:
                                print(f"[DEBUG-SUP] ADVERTENCIA: Parcela origen {partida_origen} no tiene geometr√≠as asociadas en la capa temporal")
                            elif superficie_alfa == 0:
                                print(f"[DEBUG-SUP] ADVERTENCIA: No se pudo obtener superficie alfanum√©rica para parcela origen {partida_origen}")
                        
                        elif parcela_origen.get("asociada") and not parcela_origen.get("geometry"):
                            # Est√° marcada como asociada pero no tiene geometr√≠a en la entrada, pero podr√≠a tener en la capa temporal
                            print(f"[DEBUG-SUP] ADVERTENCIA: Parcela origen {partida_origen} marcada como asociada pero sin geometr√≠a en entrada. Verificando capa temporal...")
                            # Podr√≠amos tambi√©n verificar en la capa temporal, pero por ahora solo advertimos
                            if partida_origen not in partidas_con_error:
                                errores_verificacion.append(
                                    f"La parcela origen (Partida: {partida_origen}) est√° marcada como asociada "
                                    f"pero no tiene geometr√≠a definida en la entrada. Esto puede indicar un error en los datos."
                                )
                                partidas_con_error.add(partida_origen)
                        else:
                            print(f"[DEBUG-SUP] Parcela origen {partida_origen} no est√° asociada o no tiene geometr√≠a, omitiendo validaci√≥n")
                    
                    print(f"[DEBUG-SUP] Validaci√≥n de superficies origen completada. Errores encontrados: {len(errores_verificacion)}")    
            except Exception as e:
                print(f"[DEBUG-SUP] ERROR en validaci√≥n de superficies origen: {str(e)}")
                import traceback
                traceback.print_exc()
                errores_verificacion.append(
                    f"Error al validar consistencia de superficies de parcelas origen: {str(e)}\n"
                    f"Por favor, verifique manualmente las superficies antes de continuar."
                )  
            # ========== VALIDACIONES ADICIONALES (MANTENIDAS) ==========
            
            # S509 - Control de huecos (optimizado) - No mostrar en prescripciones y desasociado 
            try:
                if layer_parcelas and item["asociada"] and tramite_objeto not in excepciones_tramite[2:5] and tramite_objeto not in prescripciones_multiples:
                    geom_principal = geom_feature.snappedToGrid(1e-4, 1e-4)
                    buffer_geom = geom_principal.buffer(0.5, 5)
                    
                    # Recolectar geometr√≠as vecinas de forma m√°s eficiente
                    vecinos_geom = []
                    for layer in layer_parcelas:
                        request = QgsFeatureRequest().setFilterRect(buffer_geom.boundingBox())
                        vecinos_geom.extend(
                            f.geometry().snappedToGrid(1e-4, 1e-4) 
                            for f in layer.getFeatures(request) 
                            if f.geometry().intersects(buffer_geom)
                        )
                    
                    if vecinos_geom:
                        geometr√≠a_total = QgsGeometry.unaryUnion([geom_principal] + vecinos_geom)
                        
                        try:
                            envolvente = geometr√≠a_total.concaveHull(0.98, False)
                        except Exception:
                            envolvente = geometr√≠a_total.convexHull()
                        
                        envolvente_buffer = envolvente.buffer(0.001, 5)
                        union_buffer_neg = geometr√≠a_total.buffer(-0.001, 5)
                        huecos_geom = envolvente_buffer.difference(union_buffer_neg)
                        
                        # Detecci√≥n de huecos
                        huecos_individuales = []
                        if not huecos_geom.isEmpty():
                            if huecos_geom.isMultipart():
                                huecos_individuales.extend(
                                    g for g in huecos_geom.asGeometryCollection() 
                                    if g.area() > T  # Usar tolerancia calculada
                                )
                            elif huecos_geom.area() > T:  # Usar tolerancia calculada
                                huecos_individuales.append(huecos_geom)
                        
                        # Detecci√≥n de anillos internos
                        anillos_internos = []
                        if geom_principal.isMultipart():
                            for poly in geom_principal.asMultiPolygon():
                                anillos_internos.extend(
                                    QgsGeometry.fromPolygonXY([ring]) 
                                    for ring in poly[1:] 
                                    if len(ring) > 0
                                )
                        else:
                            pol = geom_principal.asPolygon()
                            anillos_internos.extend(
                                QgsGeometry.fromPolygonXY([ring]) 
                                for ring in pol[1:] 
                                if len(ring) > 0
                            )
                        
                        # Validaci√≥n de huecos problem√°ticos
                        for h in huecos_individuales + anillos_internos:
                            if h.isEmpty() or h.area() <= T_2:  # Usar tolerancia calculada
                                continue
                            
                            area = h.area()
                            perimetro = h.length()
                            bbox = h.boundingBox()
                            largo = bbox.width()
                            ancho = bbox.height()
                            proporcion = largo / ancho if ancho != 0 else 0
                            concavidad = h.convexHull().area() / h.area() if h.area() != 0 else 1
                            
                            num_vertices = 0
                            if h.isMultipart():
                                multipol = h.asMultiPolygon()
                                num_vertices = sum(len(ring) for poly in multipol for ring in poly)
                            else:
                                pol = h.asPolygon()
                                num_vertices = len(pol[0]) if pol else 0
                            
                            condiciones_sospechosas = 0
                            if concavidad > 1700:
                                condiciones_sospechosas += 1
                            if num_vertices > 24:
                                condiciones_sospechosas += 1
                            if proporcion > 2.0:
                                condiciones_sospechosas += 1
                            if perimetro > 145:
                                condiciones_sospechosas += 1
                            if not h.isGeosValid():
                                condiciones_sospechosas += 1
                            
                            if condiciones_sospechosas >= 0 and area < 0.148:
                                self.selectFeatureMsg = QgsMessageBarItem(
                                    "ATENCION: El objeto seleccionado est√° generando un espacio visible en la gr√°fica porque no se ajusta a su lindera, revisar si hay que corregir el dibujo o la lindera.",
                                    level=Qgis.Warning,
                                    duration=0
                                )
                                self.iface.messageBar().pushItem(self.selectFeatureMsg)
            except Exception as e:
                error_inesperado()
                
            
            # Validaci√≥n contenido en manzanas (para √°reas peque√±as)
            try:
                if area_feature < 4000 and tramite_objeto not in [excepciones_tramite[i] for i in [2,3,4,7,8]] and tramite_objeto not in prescripciones_multiples:
                    layer_manzanas = next((lay["obj"] for lay in self.layers if lay["fisico"] == "VW_MANZANAS"), None)
                    
                    if layer_manzanas:
                        search_rect = geom_feature.boundingBox()
                        # OPTIMIZACI√ìN: Usar filterRect sin buffer innecesario
                        request = QgsFeatureRequest().setFilterRect(search_rect)
                        
                        manzana_geom = [f.geometry() for f in layer_manzanas.getFeatures(request)]
                        
                        if not manzana_geom:
                            errores_verificacion.append("El objeto geom√©trico seleccionado no se encuentra contenido dentro de una manzana.")
                        else:
                            fusion_manzanas_geom = manzana_geom[0]
                            for m in manzana_geom[1:]:
                                fusion_manzanas_geom = fusion_manzanas_geom.combine(m)
                            
                            if not fusion_manzanas_geom.isEmpty():
                                # CORRECCI√ìN: Verificar intersecci√≥n con tolerancia para bordes compartidos
                                intersect_area_manzanas = fusion_manzanas_geom.intersection(geom_feature).area()
                                
                                # Calcular qu√© porcentaje de la parcela est√° dentro de la manzana
                                porcentaje_dentro = (intersect_area_manzanas / area_feature) * 100 if area_feature > 0 else 0
                                
                                tolerancia_manzana = 5.0  # 5% de tolerancia
                                                        
                                # Solo error si menos del (100 - tolerancia_manzana)% est√° dentro
                                if porcentaje_dentro < (100 - tolerancia_manzana):
                                    # CALCULAR METROS CUADRADOS EXACTOS FUERA DE LA MANZANA
                                    area_fuera_manzana = area_feature - intersect_area_manzanas
                                    errores_verificacion.append(
                                        f"El objeto geom√©trico seleccionado no se encuentra contenido dentro de una manzana "
                                        f"(Est√° {area_fuera_manzana:.2f} m¬≤ fuera de la manzana)."
                                    )
            except Exception as e:
                error_inesperado()
                
          
            # ========== VALIDACI√ìN DE SUPERPOSICI√ìN ENTRE HERMANOS (MISMO PADRE) ==========
            if item["anidacion"] == 1:  # <-- VALIDAR SIEMPRE PARA HERMANOS
                try:
                    id_padre = item.get("id_padre")

                    if id_padre:
                        # Obtener hermanos del mismo padre (TODOS los que tengan geometr√≠a)
                        hermanos = [
                            e for e in self.dataET["entradas"]
                            if e.get("id_padre") == id_padre
                            and e.get("id") != item["id"]
                            and e.get("geometry")
                        ]

                        print(f"üîç Validando superposici√≥n con {len(hermanos)} hermanos con geometr√≠a")

                        superposiciones_hermanos = []
                        total_area_superposicion_hermanos = 0.0

                        for hermano in hermanos:
                            geom_hermano = QgsGeometry.fromWkt(hermano["geometry"])

                            # Verificar intersecci√≥n
                            if geom_feature.intersects(geom_hermano):
                                inter = geom_feature.intersection(geom_hermano)
                                area_inter = inter.area() if not inter.isEmpty() else 0.0

                                if area_inter > T_2:
                                    # Detalle para el mensaje
                                    nombre_base = hermano.get('descripcion', 'Hermano')

                                    if hermano.get('descripcion') == "PARCELA":
                                        nombre_detalle = (
                                            f"PARCELA {hermano.get('origen_o_destino', '')}: "
                                            f"ID s/Plano: {hermano.get('id_plano', 'N/A')} - "
                                            f"Mz: {hermano.get('nombre_manzana', 'N/A')}"
                                        )
                                    elif hermano.get('descripcion') == "MANZANA":
                                        nombre_detalle = f"MANZANA: ID s/Plano: {hermano.get('id_plano', 'N/A')}"
                                    else:
                                        nombre_detalle = nombre_base

                                    superposiciones_hermanos.append({
                                        'nombre': nombre_detalle,
                                        'id': hermano.get('id', 'N/A'),
                                        'area': area_inter
                                    })

                                    total_area_superposicion_hermanos += area_inter

                                    print(f"üö® SUPERPOSICI√ìN CON HERMANO ID {hermano.get('id')}: √Årea = {area_inter:.6f} m¬≤")

                        # ===== RESULTADO DE LA VALIDACI√ìN =====

                        if superposiciones_hermanos and total_area_superposicion_hermanos > T_2:
                            superposiciones_hermanos.sort(key=lambda x: x['area'], reverse=True)

                            detalle_hermanos = "\n".join([
                                f"   - {h['nombre']} (ID: {h['id']}): {'%.10f' % h['area']} m¬≤"
                                for h in superposiciones_hermanos
                            ])

                            errores_verificacion.append(
                                f"El objeto geom√©trico seleccionado se superpone con {len(superposiciones_hermanos)} parcela(s) hermanas.\n"
                                f"   Los hijos NO deben superponerse entre s√≠ en NING√öN tipo de tr√°mite.\n"
                                f"   Tolerancia Art.148 Ley 2283/68: {'%.10f' % T_2} m¬≤\n"
                                f"   √Årea total superpuesta: {'%.10f' % total_area_superposicion_hermanos} m¬≤\n"
                                f"   Detalle:\n{detalle_hermanos}"
                            )

                            print(f"üîç Total superposici√≥n entre hermanos: {total_area_superposicion_hermanos:.6f} m¬≤")
                            print(f"üîç N√∫mero de hermanos superpuestos: {len(superposiciones_hermanos)}")

                        elif superposiciones_hermanos:
                            print(f"‚ö†Ô∏è Hermanos se tocan pero dentro de tolerancia: {total_area_superposicion_hermanos:.6f} m¬≤")
                        else:
                            print("‚úÖ No se detectaron superposiciones entre hermanos")

                except Exception as e:
                    error_inesperado()

            # ========== VALIDACI√ìN DE SUPERFICIES OPTIMIZADA ==========
            validacion_remanente_realizada = False
            print('Objeto: ', str(self.dataET["tramite"]["objeto"]))
            print('Es padre: ', es_padre)
            
            try:
                if tramite_objeto in excepciones_tramite[0:2] and es_padre:
                    tolerancia_feature_area = remanente * 0.05  # 5% de tolerancia
                    print('Entr√≥ en validaci√≥n de remanente')
                    
                    if (area_feature < (remanente - tolerancia_feature_area)) or (area_feature > (remanente + tolerancia_feature_area)):
                        errores_verificacion.append(
                            f"La diferencia entre la superficie del objeto seleccionado y la superficie remanente excede un 5%. "
                            f"(Superficie del objeto seleccionado: {'%.2f' % area_feature}m¬≤. Remanente: {'%.2f' % remanente}m¬≤)"
                        )
                    # Marcar que la validaci√≥n de remanente ha sido realizada
                    validacion_remanente_realizada = True

                # Validaci√≥n de la superficie total solo si no se valid√≥ el remanente
                if not validacion_remanente_realizada:
                    tolerancia_feature_hija = float(item.get('superficie', 0)) * 0.05  # 5% de tolerancia
                    if ((area_feature < (float(item.get('superficie', 0)) - tolerancia_feature_hija)) or 
                        (area_feature > (float(item.get('superficie', 0)) + tolerancia_feature_hija))):
                        print('Entr√≥ en validaci√≥n total')
                        errores_verificacion.append(
                            f"La diferencia entre la superficie del objeto seleccionado y la superficie registrada excede un 5%. "
                            f"(Superficie del objeto seleccionado: {'%.2f' % area_feature}m¬≤. Registrado: {'%.2f' % float(item.get('superficie', 0))}m¬≤)"
                        )
            except Exception as e:
                error_inesperado()
                
            
            print('Superficie registrada: ', item['superficie'])
            print('Subtipo: ', str(self.dataET["tramite"]["subtipo"]))
            
            # Procesamiento final
            if not errores_verificacion:
                try:
                    geometry = geom_feature.asWkt()
                    payload = [{
                        "id": item["id"],
                        "featid": item["featid"],
                        "tabla": item["tabla_grafica"],
                        "geometry": geometry,
                        "id_parcela": item["id_objeto"],
                        "id_tramite": self.dataET["tramite"]["id_tramite"],
                        "dato_alfa_jur": item.get('dato_alfa_jur'),
                        "subtipo": self.dataET["tramite"]["subtipo"]
                    }]
                    
                    # √öNICA PETICI√ìN: Validaci√≥n y ejecuci√≥n directa
                    r = requests.put(
                        url=self.URL + "geometria_temporal",
                        data=json.dumps({"data": payload, "confirmar": True}),  # Puede ser True o False, ya no importa
                        headers={'Authorization': f"Bearer {self.TOKEN}"},
                        timeout=30
                    )
                    # 1. Informaci√≥n b√°sica de la respuesta HTTP
                    print(f"[DEBUG-PLUGIN] C√≥digo de estado HTTP: {r.status_code}")
                    print(f"[DEBUG-PLUGIN] Tama√±o de respuesta: {len(r.text)} bytes")
                    print(f"[DEBUG-PLUGIN] Headers de respuesta: {dict(r.headers)}")
                    print(f"[DEBUG-PLUGIN] Encoding detectado: {r.encoding}")
                    
                    # 2. Respuesta bruta (primeros 1000 caracteres)
                    raw_text = r.text
                    print(f"[DEBUG-PLUGIN] Respuesta bruta (primeros 1000 chars): {raw_text[:1000]}")
                    
                    # 3. Verificar si hay caracteres especiales o problemas
                    print(f"[DEBUG-PLUGIN] ¬øContiene 'advertencia' en texto? {'advertencia' in raw_text.lower()}")
                    print(f"[DEBUG-PLUGIN] ¬øContiene 'EXITO' en texto? {'EXITO' in raw_text}")
                    # Manejo de respuesta de la API 
                    if r.status_code == 200:
                        response_data = r.json()
                        
                        print(f"[DEBUG] Respuesta API: {response_data}")
                        
                        if "ERROR" in response_data:
                            # Error bloqueante de la API
                            if "detalles" in response_data and "ERROR" in response_data["detalles"]:
                                if isinstance(response_data["detalles"]["ERROR"], list):
                                    errores_api = "\n".join(f"‚Ä¢ {e}" for e in response_data["detalles"]["ERROR"])
                                else:
                                    errores_api = response_data["detalles"]["ERROR"]
                            else:
                                errores_api = response_data["ERROR"] if isinstance(response_data["ERROR"], str) else str(response_data["ERROR"])
                            
                            QMessageBox.warning(
                                self.dlgET, 
                                "Error en validaci√≥n del servidor", 
                                f"El servidor report√≥ los siguientes errores:\n\n{errores_api}"
                            )
                            return
                            
                        elif "EXITO" in response_data:
                            # √âxito en la operaci√≥n
                            self.loadTramiteLayerGroup(True)
                            
                            # Verificar si hay advertencia en la respuesta
                            advertencia = response_data.get("advertencia")
                            
                            if advertencia:
                                # Mostrar mensaje de √©xito CON advertencia
                                QMessageBox.warning(
                                    self.dlgET,
                                    "Advertencia de Jurisdicci√≥n",
                                    f"Geometr√≠a asociada con √©xito.\n\nPero se advierte: {advertencia}"
                                )
                            else:
                                # Mostrar mensaje de √©xito SIN advertencia
                                QMessageBox.information(
                                    self.dlgET,
                                    "√âxito",
                                    "Geometr√≠a asociada con √©xito.\n\nEl buscador puede demorar unos minutos en actualizarse."
                                )
                            
                            # Eliminar feature de capa de dibujo
                            if featureLayer:
                                featureLayer.deleteFeatures([feature.id()])
                                featureLayer.triggerRepaint()
                            
                            self.ETtabDatosEspecificos = True
                            self.procesarTramite()
                            return
                            
                        else:
                            # Respuesta inesperada
                            QMessageBox.warning(
                                self.dlgET,
                                "Respuesta inesperada",
                                f"El servidor devolvi√≥ una respuesta inesperada: {response_data}"
                            )
                            return
                            
                    elif r.status_code == 400:
                        # Error de validaci√≥n espec√≠fico de la API
                        try:
                            error_data = r.json()
                            logging.warning(f"Error de validaci√≥n API: {error_data}")
                            
                            # Extraer mensaje de error espec√≠fico - NUEVA ESTRUCTURA
                            mensaje_error = ""
                            
                            # Intentar extraer de la nueva estructura anidada
                            if "detalles" in error_data:
                                detalles = error_data["detalles"]
                                if isinstance(detalles, dict):
                                    if "detalles" in detalles:
                                        sub_detalles = detalles["detalles"]
                                        if isinstance(sub_detalles, dict) and "ERROR" in sub_detalles:
                                            if isinstance(sub_detalles["ERROR"], list):
                                                mensaje_error = "\n".join(sub_detalles["ERROR"])
                                            else:
                                                mensaje_error = str(sub_detalles["ERROR"])
                                    elif "ERROR" in detalles:
                                        if isinstance(detalles["ERROR"], list):
                                            mensaje_error = "\n".join(detalles["ERROR"])
                                        else:
                                            mensaje_error = detalles["ERROR"]
                            
                            # Si no se encontr√≥ en la nueva estructura, usar la antigua
                            if not mensaje_error:
                                if "detalles" in error_data and "ERROR" in error_data["detalles"]:
                                    if isinstance(error_data["detalles"]["ERROR"], list):
                                        mensaje_error = "\n".join(error_data["detalles"]["ERROR"])
                                    else:
                                        mensaje_error = error_data["detalles"]["ERROR"]
                                elif "ERROR" in error_data:
                                    if isinstance(error_data["ERROR"], list):
                                        mensaje_error = "\n".join(error_data["ERROR"])
                                    else:
                                        mensaje_error = error_data["ERROR"]
                            
                            if not mensaje_error:
                                mensaje_error = f"Error en actualizaci√≥n de geometr√≠a (C√≥digo: {r.status_code})"
                            
                            QMessageBox.warning(
                                self.dlgET, 
                                "Error de validaci√≥n", 
                                mensaje_error
                            )
                            
                        except Exception as e:
                            logging.error(f"Error al procesar respuesta de error: {str(e)}")
                            QMessageBox.warning(
                                self.dlgET, 
                                "Error del servidor", 
                                f"Error en actualizaci√≥n de geometr√≠a (C√≥digo: {r.status_code})"
                            )
                        return
                        
                    else:
                        # Otros errores HTTP
                        logging.warning(f"Error HTTP en actualizaci√≥n geom√©trica: {r.status_code} - {r.text}")
                        QMessageBox.warning(
                            self.dlgET, 
                            "Error del servidor", 
                            f"Error en actualizaci√≥n de geometr√≠a (C√≥digo: {r.status_code})"
                        )
                        return
                        
                except requests.exceptions.Timeout:
                    logging.warning("Timeout en conexi√≥n al servidor")
                    QMessageBox.warning(self.dlgET, "Error", "Timeout: El servidor no respondi√≥ a tiempo")
                    return
                except requests.exceptions.ConnectionError:
                    logging.warning("Error de conexi√≥n al servidor")
                    QMessageBox.warning(self.dlgET, "Error", "No se pudo conectar al servidor")
                    return
                except Exception as e:
                    logging.error(f"ERROR en comunicaci√≥n con API: {str(e)}")
                    QMessageBox.warning(self.dlgET, "Error", f"Error de comunicaci√≥n: {str(e)}")
                    return
            else:
                errores_parrafo = "".join(f"‚Ä¢ {e}\n" for e in errores_verificacion)
                QMessageBox.warning(self.dlgET, "Error en validaci√≥n", errores_parrafo)
        
        except Exception as e:
            # Captura cualquier error no controlado en el nivel m√°s alto
            logging.error(f"ERROR GLOBAL en featureAsociadaET: {str(e)}", exc_info=True)
            QMessageBox.critical(
                self.dlgET,
                "Error cr√≠tico",
                f"Se produjo un error inesperado:\n\n{str(e)}\n\n"
                "Por favor, guarde su trabajo y reintente la operaci√≥n."
            )
                    
    def desasociarTramiteGeometry(self):
        item = self.dlgET.entradasTree.model().itemFromIndex(self.dlgET.entradasTree.selectionModel().selectedIndexes()[0]).data()
        nombre_capa_dibujo = "DIBUJO:VW_PARCELAS_GRAF_ALFA" if item["tipo"] == "PARCELA" else "DIBUJO:VW_MANZANAS"
        nombre_capa_feature = "TEMPORAL:PARCELAS" if item["tipo"] == "PARCELA" else "TEMPORAL:MANZANAS"
        dibujoFeatureLayer = [l["obj"] for l in self.layers if l["fisico"] == nombre_capa_dibujo][0]
        featureLayer = [l["obj"] for l in self.layers if l["fisico"] == nombre_capa_feature][0]
        feature = None
        # S576 - Bloquear el desasociado para tr√°mites de PH
        tramite_objeto = self.dataET["tramite"]["objeto"]
        es_padre = False
        print('item: ', item)
        print(tramite_objeto)
        try:
            # 1) Si id == id_padre (caso expl√≠cito de padre)
            if item.get("id") and item.get("id_padre") and item["id"] == item["id_padre"]:
                es_padre = True

            # 2) Si anidacion == 0 -> considerarlo padre (top-level)
            elif item.get("anidacion") == 0:
                es_padre = True

            # 3) Si alguna otra entrada tiene id_padre igual al id de este item
            else:
                item_id = item.get("id")
                if item_id is not None:
                    for e in self.dataET.get("entradas", []):
                        if e.get("id_padre") == item_id:
                            es_padre = True
                            break

        except Exception as e:
            logging.warning(f"No se pudo determinar si es padre: {str(e)}")

        tipos_bloqueados = [
            'Mensura De Divisi√≥n de la Edificaci√≥n Existente Para Someter al R√©gimen de Propiedad Horizontal en Base a Mensura Registrada',
            'Mensura de Divisi√≥n de la Edificaci√≥n Existente y a Construir Para Someter al R√©gimen de Propiedad Horizontal en Base a Mensura Registrada',
            'Mensura de Modificaci√≥n de la Divisi√≥n de la Edificaci√≥n Existente Para Someter al R√©gimen de Propiedad Horizontal en Base a Mensura Registrada',
            'Propiedad Horizontal'
        ]

        if tramite_objeto in tipos_bloqueados and es_padre:
            QMessageBox.critical(
                self.dlgET,
                "Error",
                "No se puede modificar la origen en este tipo de tr√°mite, por lo que se debe modificar la destino para que luego se efect√∫en los cambios deseados."
            )
            return  # Corta la ejecuci√≥n
        for f in featureLayer.getFeatures():
            if f.attribute("id_objeto") == item["id_objeto"]:
                feature = f
        try:
            r = requests.delete(url = self.URL + "geometria_temporal", data = json.dumps([{"featid": item["featid"],"tabla": item["tabla_grafica"], "id_tramite": self.dataET["tramite"]["id_tramite"]}]), 
                             headers={'Authorization': "Bearer {}".format(self.TOKEN)})
            if r.status_code == 200:
                self.loadTramiteLayerGroup(True)
                QMessageBox.information(self.dlgET, "√âxito", "Geometr√≠a desasociada con √©xito")
                if feature is not None and not self.dataET["parcelas_repetidas"]:
                    message = QMessageBox(QMessageBox.Question,"Desasociar geometr√≠a", "¬øDesea copiar la geometr√≠a a la capa de dibujo correspondiente?",
                        QMessageBox.Yes|QMessageBox.No, self.dlgET)
                    message.buttons()[0].setText("Si") 
                    reply = message.exec()
                    if reply == QMessageBox.Yes:
                        new_dibujo_feature = QgsFeature()
                        new_dibujo_feature.setGeometry(feature.geometry())
                        dibujoFeatureLayer.dataProvider().addFeatures([new_dibujo_feature])
                        dibujoFeatureLayer.triggerRepaint()

                self.ETtabDatosEspecificos = True
                self.procesarTramite()
            else:
                logging.warning("Error en desasociado geometrico de schema temporal")
                QMessageBox.warning(self.dlgET, "Error", "Error en desasociado de geometr√≠a")
        except requests.exceptions.ConnectionError:
            logging.warning("Error en servidor")
            QMessageBox.warning(self.dlgET, "Error", "Servidor no disponible")
        except (KeyboardInterrupt, SystemExit): raise
        except: 
            logging.warning("ERROR : " + str(sys.exc_info()[0]) + str(sys.exc_info()[1])  + str(sys.exc_info()[2]) + "Line: " + str(sys.exc_info()[2].tb_lineno))
            QMessageBox.warning(self.dlgET, "Error", "Error en servidor")

    def highlightTramiteFeature(self,item):
        [l["obj"] for l in self.layers if l["fisico"] == "TEMPORAL:PARCELAS"][0].removeSelection()
        [l["obj"] for l in self.layers if l["fisico"] == "TEMPORAL:MANZANAS"][0].removeSelection()
        nombre_capa_feature = "TEMPORAL:PARCELAS" if item["tipo"] == "PARCELA" else "TEMPORAL:MANZANAS"
        featureLayer = [l["obj"] for l in self.layers if l["fisico"] == nombre_capa_feature][0]
        feature = None
        for f in featureLayer.getFeatures():
            if f.attribute("id_objeto") == item["id_objeto"]:
                featureLayer.select(f.id())

    def loadTramiteLayerGroup(self, removal = False):
        if not removal:
            group = list(filter(lambda l: not l["inicial"],self.groups))
            group_id = group[0]["id"]
            group = group[0]["obj"]
            # Set Name
            self.tramiteGroupString = f"Tramite N¬∫: {self.dataET['tramite']['id_tramite']}"
            group.setName(self.tramiteGroupString)
            # Add layers
            for l in [l for l in self.dataLayers["layers"] if l["grupo"] == group_id]:
                qgis_layers = QgsProject.instance().mapLayers().keys() # Save previous list of loaded layers
                layer_path = os.path.join(self.current_dir,f"temp/{l['nombre']}.qlr")
                f = open(layer_path, "x")
                f.write(l["estilo"])
                f.close()
                QgsLayerDefinition().loadLayerDefinition(layer_path,QgsProject.instance(),group)
                os.remove(layer_path)
                # save newly added layer by obtaining the current list of layers minus the previous list of layers
                new_layer = QgsProject.instance().mapLayers()[list(set(QgsProject.instance().mapLayers()) - set(qgis_layers))[0]] 
                layer_provider = new_layer.dataProvider()
                layer_provider.addAttributes([QgsField("id",QVariant.Int)])
                layer_provider.addAttributes([QgsField("id_objeto",QVariant.Int)])
                layer_provider.addAttributes([QgsField("id_padre",QVariant.Int)])
                layer_provider.addAttributes([QgsField("anidacion",QVariant.Int)])
                new_layer.updateFields()
                self.layers.append({"id": l["id"], 
                                    "tabla": l["tabla"],
                                    "tipo": "oms" if l["tipo"] == 0 else "", 
                                    "fisico": l["nombre_fisico"],
                                    "obj": new_layer,
                                    "default_visible": l["visible"]})
        else:
            root = QgsProject.instance().layerTreeRoot()
            group = root.findGroup(self.tramiteGroupString)
            if group is not None:
                self.tramiteGroupString = "Tramite"
                group.setName(self.tramiteGroupString)
                for child in group.children():
                    if isinstance(child,QgsLayerTreeGroup):
                        root.removeChildNode(child)
                    else:
                        QgsProject.instance().removeMapLayer(child.layerId())
            # Remove temp layers of tramite
            layers_with_temp_removed = [l for l in self.layers if str(l["fisico"]).find("TEMPORAL:") == -1]
            self.layers = layers_with_temp_removed
            self.iface.mapCanvas().refresh()

    def adjuntoModalDescription(self):
        if self.first_start_DocInfo == True:
            self.first_start_DocInfo = False
            self.dlgDI = DocInfoDialog()
            # Lock resizing for user
            self.dlgDI.setMaximumSize(self.dlgDI.size())
            self.dlgDI.setMinimumSize(self.dlgDI.size())
            self.defaultSizeDI = self.dlgDI.size()
            self.dlgDI.setGeometry((QDesktopWidget().screenGeometry().width() / 2) - (self.defaultSizeDI.width() / 2),(QDesktopWidget().screenGeometry().height() / 2) - (self.defaultSizeDI.height() / 2),self.defaultSizeDI.width(),self.defaultSizeDI.height())

        self.dlgDI.textDescripcion.setPlainText(self.dlgET.tableAdjuntos.item(self.dlgET.tableAdjuntos.currentRow(),0).data(32)["descripcion"])
        self.dlgDI.textObservaciones.setPlainText(self.dlgET.tableAdjuntos.item(self.dlgET.tableAdjuntos.currentRow(),0).data(32)["observaciones"])
        self.dlgDI.setModal(True)
        self.dlgDI.show()

    def changeBandejaPage(self,page):
        if page == "reload":
            self.waitMsg = self.messageWait("Espere mientras se carga la bandeja de tr√°mites...")
            thread = self.ServerLoaderBandejaTramites(self,self.bandejaPage)
            thread.finished.connect(self.finishedBandejaTramites)
            thread.failed.connect(self.failedBandejaTramites)
            thread.start()
        else:
            pagination = { 
                "next": self.bandejaPage + 1,
                "prev": self.bandejaPage - 1 if  self.bandejaPage - 1 >= 0 else 0,
            }
            self.bandejaPage = pagination[page]
            self.finishedBandejaTramites()

    def procesarTramite(self):
        if self.dlgBT.tableTramites.item(self.dlgBT.tableTramites.currentRow(),0) is not None:
            self.waitMsg = self.messageWait("Espere mientras se obtiene el tr√°mite...")
            id_tramite = self.dlgBT.tableTramites.item(self.dlgBT.tableTramites.currentRow(),0).data(32)["id_tramite"]
            thread = self.ServerLoaderTramiteDatos(self,id_tramite)
            thread.finished.connect(self.finishedGetTramite)
            thread.failed.connect(self.failedGetTramite)
            thread.start() 

    def tramiteTreeButtons(self):
        self.dlgET.asociarButton.setVisible(self.dlgET.tramiteTabs.currentIndex() == 1)
        self.dlgET.desasociarButton.setVisible(self.dlgET.tramiteTabs.currentIndex() == 1)
        self.dlgET.asociarButton.setEnabled(False)
        self.dlgET.desasociarButton.setEnabled(False)

    def tramiteTreeSelectedItem(self):
        item = self.dlgET.entradasTree.model().itemFromIndex(self.dlgET.entradasTree.selectionModel().selectedIndexes()[0]).data()
        self.dlgET.asociarButton.setEnabled(not item["asociada"] and item.get("descripcion", "") != "SIN ORIGEN")
        self.dlgET.desasociarButton.setEnabled(item["asociada"])
        self.highlightTramiteFeature(item)

    def asociarTramiteGeometry(self):
        item = self.dlgET.entradasTree.model().itemFromIndex(self.dlgET.entradasTree.selectionModel().selectedIndexes()[0]).data()
        self.selectMapFeatureByClick(capa = f"DIBUJO:{item['tabla']}")       

    def finishedGetTramite(self): 
        self.waitMsg.done(0)
        self.toggleEnableToolbarIcons(False)
        self.whichDialog = "EditTramite"
        if self.first_start_EditTramite == True:
            self.first_start_EditTramite = False
            self.dlgET = EditTramiteDialog()
            # Lock resizing for user
            self.dlgET.setMaximumSize(self.dlgET.size())
            self.dlgET.setMinimumSize(self.dlgET.size())
            self.defaultSizeET = self.dlgET.size()
            self.dlgET.setGeometry(
                int((QDesktopWidget().screenGeometry().width() / 2) - (self.defaultSizeET.width() / 2)),
                int((QDesktopWidget().screenGeometry().height() / 2) - (self.defaultSizeET.height() / 2)),
                self.defaultSizeET.width(),
                self.defaultSizeET.height()
            )
            # Table config
            self.dlgET.tableAdjuntos.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
            self.dlgET.tableAdjuntos.horizontalHeader().setVisible(True) # only because QT Designer keeps setting this to False
            # Event handlers
            self.dlgET.closed.connect(lambda: self.toggleEnableToolbarIcons(False))
            self.dlgET.rejected.connect(lambda: self.toggleEnableToolbarIcons(False))
            self.dlgET.tableAdjuntos.itemDoubleClicked.connect(self.adjuntoModalDescription)
            self.dlgET.tramiteTabs.currentChanged.connect(self.tramiteTreeButtons)
            self.dlgET.desasociarButton.clicked.connect(self.desasociarTramiteGeometry)
            self.dlgET.asociarButton.clicked.connect(self.asociarTramiteGeometry)

        self.securityEditTramite()
        self.loadTramiteLayerGroup()
        # Tab
        self.dlgET.tramiteTabs.setCurrentIndex(1 if self.ETtabDatosEspecificos else 0)
        self.ETtabDatosEspecificos = False
        self.tramiteTreeButtons()
        # Data tab
        self.dlgET.lineId.setText(str(self.dataET["tramite"]["id_tramite"]))
        self.dlgET.lineNumeroTramite.setText(str(self.dataET["tramite"]["numero"]))
        self.dlgET.lineIniciador.setText(str(self.dataET["tramite"]["iniciador"]))
        self.dlgET.lineEstado.setText(str(self.dataET["tramite"]["estado"]))
        self.dlgET.lineTipo.setText(str(self.dataET["tramite"]["tipo"]))
        self.dlgET.lineJurisdiccion.setText(str(self.dataET["tramite"]["jurisdiccion"]))
        
        # Fix for fecha ingreso
        self.dataET["tramite"]["fecha_vto"] = re.search('([0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2})\\.?.*', self.dataET["tramite"]["fecha_vto"]) if self.dataET["tramite"]["fecha_vto"] is not None else None
        self.dataET["tramite"]["fecha_vto"] = self.dataET["tramite"]["fecha_vto"].group(1) if self.dataET["tramite"]["fecha_vto"] is not None else None
        self.dlgET.DateVencimiento.setDateTime(QDateTime.fromString(self.dataET["tramite"]["fecha_vto"] if self.dataET["tramite"]["fecha_vto"] is not None else "1900-01-01 00:00:00","yyyy-MM-dd HH:mm:ss"))
        
        # Fix for fecha libro diario weird format with microseconds and such        
        self.dataET["tramite"]["fecha_libro_diario"] = re.search('([0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2})\\.?.*', self.dataET["tramite"]["fecha_libro_diario"]) if self.dataET["tramite"]["fecha_libro_diario"] is not None else None
        self.dataET["tramite"]["fecha_libro_diario"] = self.dataET["tramite"]["fecha_libro_diario"].group(1) if self.dataET["tramite"]["fecha_libro_diario"] is not None else None
        self.dlgET.DateLibroDiario.setDateTime(QDateTime.fromString(self.dataET["tramite"]["fecha_libro_diario"] if self.dataET["tramite"]["fecha_libro_diario"] is not None else "1900-01-01 00:00:00","yyyy-MM-dd HH:mm:ss"))
        
        # Fix for fecha ingreso
        self.dataET["tramite"]["fecha_ingreso"] = re.search('([0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2})\\.?.*', self.dataET["tramite"]["fecha_ingreso"]) if self.dataET["tramite"]["fecha_ingreso"] is not None else None
        self.dataET["tramite"]["fecha_ingreso"] = self.dataET["tramite"]["fecha_ingreso"].group(1) if self.dataET["tramite"]["fecha_ingreso"] is not None else None
        self.dlgET.DateIngreso.setDateTime(QDateTime.fromString(self.dataET["tramite"]["fecha_ingreso"],"yyyy-MM-dd HH:mm:ss")) if self.dataET["tramite"]["fecha_ingreso"] is not None else self.dlgET.DateIngreso.clear()
        
        # Rest of stuff
        self.dlgET.linePrioridad.setText(str(self.dataET["tramite"]["prioridad"]))
        self.dlgET.lineObjeto.setText(str(self.dataET["tramite"]["objeto"]))
        self.dlgET.lineLocalidad.setText(str(self.dataET["tramite"]["localidad"]))
        self.dlgET.textMotivo.setText(str(self.dataET["tramite"]["motivo"]))
        # Adjunto Tab
        self.dlgET.tableAdjuntos.clearSelection()
        self.dlgET.tableAdjuntos.setRowCount(0)
        for t in self.dataET["adjuntos"]:
            self.dlgET.tableAdjuntos.insertRow(self.dlgET.tableAdjuntos.rowCount())
            items = []
            items.append(QTableWidgetItem(t["fecha"][:10] if t["fecha"] is not None else ""))
            items.append(QTableWidgetItem(t["persona"]))
            items.append(QTableWidgetItem(t["tipo"]))
            items.append(QTableWidgetItem(t["adjunto"]))
            for i in range(4):
                font = items[i].font()
                font.setPointSize(13)
                items[i].setFont(font)
                items[i].setFlags(Qt.ItemIsEnabled|Qt.ItemIsSelectable)
                items[i].setData(32,{"id_documento": t["id_documento"], "observaciones": t["observaciones"], "descripcion": t["descripcion"]})
                self.dlgET.tableAdjuntos.setItem(self.dlgET.tableAdjuntos.rowCount() - 1,i,items[i])
        # Tab with tree of entradas. Entradas tree.
        # Model and config
        model = QStandardItemModel()
        # Fix for parcelas
        for e in self.dataET["entradas"]:
            if e['tabla'] == 'VW_PARCELAS':
                e['tabla'] = 'VW_PARCELAS_GRAF_ALFA'
        # Parents
        parents_data = [e for e in self.dataET["entradas"] if e["id_padre"] is None]
        parents = []
        # S570 - Alerta en QGIS de parcelas origenes repetidas.
        if self.dataET["parcelas_repetidas"] and any(e.get("asociada") for e in self.dataET["entradas"]):
            self.selectFeatureMsg = QgsMessageBarItem(
                "ATENCI√ìN: LA PARCELA ORIGEN TIENE VARIOS GR√ÅFICOS, SE DEBE VERIFICAR Y CORREGIR MANUALMENTE PARA EVITAR INCONSISTENCIAS.",
                level=Qgis.Warning,
                duration=0
            )
            self.iface.messageBar().pushItem(self.selectFeatureMsg)
        for p in parents_data:
            if p['descripcion'] == "PARCELA":
                descripcion = f"{p['descripcion']} {p['origen_o_destino']}: Partida Inmobiliaria: {p['partida_inmobiliaria']} Gr√°fico: {p['featid']} Nomenclatura Catastral: {p['nomenclatura'] if p['nomenclatura'] else ''}"
            if p['descripcion'] == "MANZANA":
                descripcion = f"{p['descripcion']}: ID s/Plano: {p['id_plano']}"
            if p['descripcion'] == "VIA":
                descripcion = f"{p['descripcion']}: ID s/Plano: {p['id_plano']} ‚Äì Tipo: {p['tipo']}"
            # S573
            if p.get("asociada"):
                if "superficie_repetidas" in p and "superficie" in p:
                    if Decimal(p["superficie_repetidas"]) < Decimal(p["superficie"]):
                        # Asociada pero con superficie insuficiente => marcar como inconsistente
                        parents.append(QStandardItem(QIcon(os.path.join(self.current_dir, 'icons/cancel.png')), descripcion))
                    else:
                        # Asociada y superficies OK
                        parents.append(QStandardItem(QIcon(os.path.join(self.current_dir, 'icons/ok.png')), descripcion))
                else:
                    # Asociada pero no hay datos de superficie => dejar OK por defecto
                    parents.append(QStandardItem(QIcon(os.path.join(self.current_dir, 'icons/ok.png')), descripcion))
            else:
                # No est√° asociada => √≠cono rojo siempre
                parents.append(QStandardItem(QIcon(os.path.join(self.current_dir, 'icons/cancel.png')), descripcion))
            parents[-1].setData({"id": p["id"],
                                 "asociada": p["asociada"] if "asociada" in p else False,
                                 "tipo": p["descripcion"], 
                                 "tabla_grafica": p["tabla_grafica"], 
                                 "featid": p["featid"],
                                 "tabla": p["tabla"],
                                 "superficie": p["superficie"] if "superficie" in p else None,
                                 "anidacion": 0,
                                 "id_objeto": p["id_objeto"] if "id_objeto" in p else None,
                                 "dato_alfa_jur": p["dato_alfa_jur"] if "dato_alfa_jur" in p else None,
                                 "nombre_manzana": p["nombre_manzana"] if "nombre_manzana" in p else None,
                                 "partida_inmobiliaria": p["partida_inmobiliaria"] if "partida_inmobiliaria" in p else None})
            p["anidacion"] = 0
            font = parents[-1].font()
            font.setPointSize(13)
            parents[-1].setFont(font)
            model.appendRow(parents[-1])

        children_data = [copy.copy(e) for e in self.dataET["entradas"] if e["id_padre"] is not None]
        children = []
        runs = 0
        while len(children_data) > 0:
            for c in children_data:
                # if c["tabla_grafica"] == None: #borrar
                #     c["tabla_grafica"] = "oa_division"
                parent = None
                if c["id_padre"] in [p.data()["id"] for p in parents]:
                    parent = [p for p in parents if p.data()["id"] == c["id_padre"]][0]
                elif c["id_padre"] in [p.data()["id"] for p in children]:
                    parent = [p for p in children if p.data()["id"] == c["id_padre"]][0]
                elif str(self.dataET["tramite"]["objeto"]) in ['Mensura Para Prescripci√≥n Adquisitiva', 'Mensura Para Prescripci√≥n Adquisitiva y Divisi√≥n', 'Mensura para reputacion de dominio', 'Mensura para reputacion de dominio y divisi√≥n', 'Mensura Para Prescripci√≥n Administrativa Ley N¬∞ 24320', 'Mensura para Plan de Regularizaci√≥n Dominial seg√∫n Ley 5836/2008 y modificatoria Ley 6211/2013']:
                    parents.append(QStandardItem(QIcon(os.path.join(self.current_dir,'icons/ok.png')), 'PARCELAS SIN ORIGEN'))
                    parents[-1].setData({"id": c["id_padre"],
                                 "asociada": False,
                                 "tipo": c["descripcion"], 
                                 "descripcion" : "SIN ORIGEN",
                                 "tabla_grafica": c["tabla_grafica"], 
                                 "featid": c["featid"],
                                 "tabla": c["tabla"],
                                 "superficie": c["superficie"] if "superficie" in c else None,
                                 "anidacion": 0,
                                 "dato_alfa_jur": c["dato_alfa_jur"] if "dato_alfa_jur" in c else None,
                                 "id_objeto": c["id_objeto"] if "id_objeto" in c else None})
                    font = parents[-1].font()
                    font.setPointSize(13)
                    parents[-1].setFont(font)
                    model.appendRow(parents[-1])
                    parent = parents[-1]
                if parent:
                    if c['descripcion'] == "PARCELA":
                        descripcion = f"{c['descripcion']} {c['origen_o_destino']}: ID s/Plano: {c['id_plano']} - Mz: {c['nombre_manzana']} ‚Äì Tipo: {c['tipo'] if 'tipo' in c else ''}"
                    if c['descripcion'] == "MANZANA":
                        descripcion = f"{c['descripcion']}: ID s/Plano: {c['id_plano'] if 'id_plano' in c else ''}"
                    if c['descripcion'] == "VIA":
                        descripcion = f"{c['descripcion']}: ID s/Plano: {c['id_plano']} ‚Äì Tipo: {c['tipo']}"
                    if "asociada" in c and c["asociada"]:
                        child = QStandardItem(QIcon(os.path.join(self.current_dir,'icons/ok.png')), descripcion)
                    else:
                        child = QStandardItem(QIcon(os.path.join(self.current_dir,'icons/cancel.png')),descripcion)
                    child.setData({"id": c["id"],
                                   "id_padre":c["id_padre"], 
                                   "asociada": c["asociada"] if "asociada" in c else False,
                                   "tipo": c["descripcion"], 
                                   "tabla_grafica": c["tabla_grafica"], 
                                   "tabla": c["tabla"],
                                   "featid": c["featid"],
                                   "superficie": c["superficie"] if "superficie" in c else None,
                                   "anidacion": parent.data()["anidacion"] + 1,
                                   "dato_alfa_jur": c["dato_alfa_jur"] if "dato_alfa_jur" in c else None,
                                   "nombre_manzana": c["nombre_manzana"] if "nombre_manzana" in c else None,
                                   "id_objeto": c["id_objeto"] if "id_objeto" in c else None})
                    for e in self.dataET["entradas"]:
                        if e["id"] == c["id"]:
                            e["anidacion"] = parent.data()["anidacion"] + 1
                    font = child.font()
                    font.setPointSize(13)
                    child.setFont(font)
                    parent.appendRow(child)
                    children.append(child)
                    children_data.pop(children_data.index(c))
                    break
        print('Configurando el modelo del QTreeView...')
        print('N√∫mero de padres:', len(parents))
        print('N√∫mero de hijos:', len(children))         
        # Tree view configs
        self.dlgET.entradasTree.setModel(model)
        self.dlgET.entradasTree.setUniformRowHeights(True)
        self.dlgET.entradasTree.setHeaderHidden(True)
        self.dlgET.entradasTree.expandAll() 
        self.dlgET.entradasTree.horizontalScrollBar().setEnabled(True)
        self.dlgET.entradasTree.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.dlgET.entradasTree.header().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.dlgET.entradasTree.header().setStretchLastSection(False)
        self.dlgET.entradasTree.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)
        self.dlgET.entradasTree.setEditTriggers(QAbstractItemView.NoEditTriggers)


        # Load geometries
        for e in self.dataET['entradas']:
            if "geometry" in e and e["geometry"] is not None:
                g = QgsGeometry.fromWkt(e["geometry"])
                feature = QgsFeature()
                fields = QgsFields()
                id_field = QgsField("id",QVariant.Int)
                id_objeto_field = QgsField("id_objeto",QVariant.Int)
                id_padre_field = QgsField("id_padre",QVariant.Int)
                anidacion_field = QgsField("anidacion",QVariant.Int)
                fields.append(id_field)
                fields.append(id_objeto_field)
                fields.append(id_padre_field)
                fields.append(anidacion_field)
                feature.setFields(fields)
                feature.setAttribute("id",e["id"])
                feature.setAttribute("id_objeto",e["id_objeto"])
                feature.setAttribute("id_padre",e["id_padre"])
                feature.setAttribute("anidacion",e["anidacion"])
                feature.setGeometry(g)
                if e["descripcion"] == "PARCELA":
                    layer = [lay["obj"] for lay in self.layers if lay["fisico"] == "TEMPORAL:PARCELAS"][0]
                    layer.dataProvider().addFeatures([feature])
                    layer.commitChanges()
                elif e["descripcion"] == "MANZANA":
                    layer = [lay["obj"] for lay in self.layers if lay["fisico"] == "TEMPORAL:MANZANAS"][0]
                    layer.dataProvider().addFeatures([feature])
                    layer.commitChanges()
        # Zoom in 
        zoomed_in = False
        layer = [lay["obj"] for lay in self.layers if lay["fisico"] == "TEMPORAL:PARCELAS"][0]
        features = [f for f in layer.getFeatures()]
        if len(features) > 0:
            for f in features:
                layer.select(f.id())
                box = layer.boundingBoxOfSelected()
                self.iface.mapCanvas().setExtent(box)
                self.iface.mapCanvas().refresh()
                zoomed_in = True
                break
        if not zoomed_in:
            layer = [lay["obj"] for lay in self.layers if lay["fisico"] == "TEMPORAL:MANZANAS"][0]
            features = [f for f in layer.getFeatures()]
            for f in features:
                layer.select(f.id())
                box = layer.boundingBoxOfSelected()
                self.iface.mapCanvas().setExtent(box)
                self.iface.mapCanvas().refresh()
                zoomed_in = True
                break

        # Connect tree events
        try: self.dlgET.entradasTree.selectionModel().selectionChanged.disconnect()
        except (KeyboardInterrupt, SystemExit): raise
        except: pass
        self.dlgET.entradasTree.selectionModel().selectionChanged.connect(self.tramiteTreeSelectedItem)

       # Deselect all features from all layers
        for l in [l["obj"] for l in self.layers if l["tipo"] != "oms"]:
            l.removeSelection()
        # Dialog Show
        print('Asignando datos a los √≠tems del QTreeView...')
        print('N√∫mero de padres creados:', len(parents))
        print('N√∫mero de hijos creados:', len(children))
        self.minimizeDialog("dlgBT")
        self.dlgET.show()

    def failedGetTramite(self, type):
        self.waitMsg.done(0)
        if type == "server":
            logging.warning("Error en servidor")
            QMessageBox.warning(self.dlgBT, "Error", "Servidor no disponible.")
        else:
            logging.warning("Error en obtenci√≥n de tr√°mite")
            QMessageBox.warning(self.dlgBT, "Error", "Error al obtener tr√°mite.")
    """
        -----------------
    """
    # Change Password
    def finishedChangePass(self): 
        self.waitMsg.done(0)
        if self.passChange:
            self.passChange = False
            QMessageBox.information(self.iface.mainWindow(), "¬°√âxito!", "Cambio de contrase√±a exitoso. Favor de volver a ingresar con su contrase√±a nueva.")
        else:
            self.iface.messageBar().pushMessage(
                "¬°√âxito!", "Cambio de contrase√±a exitoso",level=Qgis.Success, duration=3)

    def failedChangePass(self, type):
        self.waitMsg.done(0)
        if type == "server":
            logging.warning("Error en servidor")
            QMessageBox.warning(self.iface.mainWindow(), "Error", "Servidor no disponible.")
        else:
            logging.warning("Error en cambio de contrase√±a")
            QMessageBox.warning(self.iface.mainWindow(), "Error", "Error al intentar actualizar la contrase√±a.")

    def finishedBandejaTramites(self):
        self.waitMsg.done(0)
        self.dlgBT.lineUsuario.setText(f"{self.user_data['Nombre']} {self.user_data['Apellido']}")
        self.dlgBT.lineSector.setText(self.dataBT['sector'])
        self.dlgBT.tableTramites.clearSelection()
        self.dlgBT.tableTramites.setRowCount(0)
        desde = self.bandejaPage * 10 + 1
        hasta = self.bandejaPage * 10 + 10
        total = self.dataBT['cant']
        self.dlgBT.labelMostrando.setText(f"Mostrando del {desde} al {hasta if hasta <= total else total} de un total de {total}")
        self.dlgBT.prevButton.setEnabled(self.bandejaPage > 0)
        self.dlgBT.nextButton.setEnabled(self.bandejaPage * 10 + 10 < self.dataBT['cant'])

        for t in self.dataBT["tramites"][desde - 1 : hasta]:
            self.dlgBT.tableTramites.insertRow(self.dlgBT.tableTramites.rowCount())
            items = []
            items.append(QTableWidgetItem(str(t["id_tramite"])))
            items.append(QTableWidgetItem(t["numero"]))
            items.append(QTableWidgetItem(t["tipo"]))
            items.append(QTableWidgetItem(t["objeto"]))
            items.append(QTableWidgetItem(t["prioridad"]))
            items.append(QTableWidgetItem(t["fecha_venc"][:10] if t["fecha_venc"] is not None else ""))
            for i in range(6):
                font = items[i].font()
                font.setPointSize(13)
                items[i].setFont(font)
                items[i].setFlags(Qt.ItemIsEnabled|Qt.ItemIsSelectable)
                items[i].setData(32,{"id_tramite": t["id_tramite"]})
                self.dlgBT.tableTramites.setItem(self.dlgBT.tableTramites.rowCount() - 1,i,items[i])
        self.dlgBT.show()

    def failedBandejaTramites(self,type):
        if type == "db":
            QMessageBox.warning(self.iface.mainWindow(), "Error", "Error en base de datos")
        elif type == "server":
            logging.warning("Error en servidor")
            QMessageBox.warning(self.iface.mainWindow(), "Error", "Servidor no disponible.")

    def performConsulta(self):
        mostrados = 0
        self.dlgC.resultsTable.clearSelection()
        self.dlgC.resultsTable.setRowCount(0)
        self.dlgC.labelNoEncontrado.setVisible(False)
        self.dlgC.labelResultados.setVisible(False)

        try:
            # Realiza la solicitud al servidor
            r = requests.get(url=self.URL + "search", 
                            data=json.dumps({"search_terms": self.dlgC.lineSearch.text(), 
                                            "tipo": self.dlgC.comboObjeto.currentText().lower()}),
                            headers={'Authorization': "Bearer {}".format(self.TOKEN)})

            if r and r.status_code == 200:
                logging.info("Successful search request")
                total_docs = int(r.json()["response"]["numFound"])
                docs = r.json()["response"]["docs"]
                rows = int(r.json()["responseHeader"]["params"]["rows"])

                if len(docs) > 0:
                    # Ajustar el tama√±o de la ventana seg√∫n los resultados
                    self.dlgC.setMaximumSize(self.defaultSizeC)
                    self.dlgC.setMinimumSize(self.defaultSizeC)
                    self.dlgC.resize(self.defaultSizeC)

                    for d in docs:
                        # Manejo del objeto dependiendo del tipo
                        if self.dlgC.comboObjeto.currentText().lower() not in ['parcelas', 'prescripciones']:
                            d['dato_tienegeom'] = d.get('dato_tienegeom') == "TRUE" if d.get('dato_tienegeom') else bool(d.get('featids'))
                            d['descripcion'] = re.sub(r'<br>', "\n", d['descripcion'])

                            # Verifica si hay featids
                            featids_value = d['featids'] if 'featids' in d else ['']

                            # Repite la fila por cada featid
                            for featid in featids_value:
                                self.dlgC.resultsTable.insertRow(self.dlgC.resultsTable.rowCount())
                                items = []

                                # Crear las columnas de la tabla
                                item_icon = QTableWidgetItem(QIcon(os.path.join(self.current_dir, 'icons/ok.png')) if d['dato_tienegeom'] else QIcon(os.path.join(self.current_dir, 'icons/cancel.png')), "")
                                item_nombre = QTableWidgetItem(f"{d['nombre'] if 'nombre' in d else ''}{'-' if 'nombre' in d and 'dato_nomenclatura' in d else ''}{d['dato_nomenclatura'] if 'dato_nomenclatura' in d else ''}")
                                item_descripcion = QTableWidgetItem(d['descripcion'])
                                item_featid = QTableWidgetItem(str(featid))

                                # A√±adir los items a la lista
                                items.append(item_icon)
                                items.append(item_nombre)
                                items.append(item_descripcion)
                                items.append(item_featid)

                                mostrados += 1

                                # Aplicar formato y asociar los datos
                                for i in range(4):
                                    font = items[i].font()
                                    font.setPointSize(10)
                                    items[i].setFont(font)
                                    items[i].setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable)
                                    items[i].setData(32, d)

                                    # A√±adir el item a la tabla
                                    self.dlgC.resultsTable.setItem(self.dlgC.resultsTable.rowCount() - 1, i, items[i])

                        else:
                            # Manejo especial para parcelas y prescripciones
                            if str(d['descripcion'])[str(d['descripcion']).find('Superficie') + 12: str(d['descripcion']).find('Superficie') + 15] > '0 m2':
                                d['dato_tienegeom'] = d.get('dato_tienegeom') == "TRUE" if d.get('dato_tienegeom') else bool(d.get('featids'))
                                d['descripcion'] = re.sub(r'<br>', "\n", d['descripcion'])

                                # Verifica si hay featids
                                featids_value = d['featids'] if 'featids' in d else ['']

                                # Repite la fila por cada featid
                                for featid in featids_value:
                                    self.dlgC.resultsTable.insertRow(self.dlgC.resultsTable.rowCount())
                                    items = []

                                    # Crear las columnas de la tabla
                                    item_icon = QTableWidgetItem(QIcon(os.path.join(self.current_dir, 'icons/ok.png')) if d['dato_tienegeom'] else QIcon(os.path.join(self.current_dir, 'icons/cancel.png')), "")
                                    item_nombre = QTableWidgetItem(f"{d['nombre'] if 'nombre' in d else ''}{'-' if 'nombre' in d and 'dato_nomenclatura' in d else ''}{d['dato_nomenclatura'] if 'dato_nomenclatura' in d else ''}")
                                    item_descripcion = QTableWidgetItem(d['descripcion'])
                                    item_featid = QTableWidgetItem(str(featid))

                                    # A√±adir los items a la lista
                                    items.append(item_icon)
                                    items.append(item_nombre)
                                    items.append(item_descripcion)
                                    items.append(item_featid)

                                    mostrados += 1

                                    # Aplicar formato y asociar los datos
                                    for i in range(4):
                                        font = items[i].font()
                                        font.setPointSize(10)
                                        items[i].setFont(font)
                                        items[i].setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable)
                                        items[i].setData(32, d)

                                        # A√±adir el item a la tabla
                                        self.dlgC.resultsTable.setItem(self.dlgC.resultsTable.rowCount() - 1, i, items[i])

                    # Mostrar resultados adicionales si hay m√°s documentos
                    if total_docs > rows:
                        self.dlgC.labelResultados.setVisible(True)
                        self.dlgC.labelResultados.setText(f"Mostrando {mostrados} de {total_docs} resultados. Para una mejor precisi√≥n, ajuste el filtro ingresado.")
                    if len(docs) == 1 and self.dlgC.comboObjeto.currentText().lower() != 'parcelas':
                        self.consultaItemClicked(items[0], no_error_message=True)
                    if len(docs) == 1 and self.dlgC.comboObjeto.currentText().lower() == 'parcelas':
                        if str(d['descripcion'])[str(d['descripcion']).find('Superficie') + 12: str(d['descripcion']).find('Superficie') + 15] in ['0 m2', '0 ha']:
                            self.dlgC.labelNoEncontrado.setVisible(True)
                            self.dlgC.labelResultados.setVisible(False)
                        else:
                            self.consultaItemClicked(items[0], no_error_message=True)
                else:
                    # Ajustar el tama√±o si no hay resultados
                    self.dlgC.setMaximumSize(self.smallerSizeC)
                    self.dlgC.setMinimumSize(self.smallerSizeC)
                    self.dlgC.resize(self.smallerSizeC)
                    self.dlgC.labelNoEncontrado.setVisible(True)
                    self.dlgC.labelResultados.setVisible(False)
            else:
                logging.warning("Error en busqueda: " + str(sys.exc_info()[0]) + str(sys.exc_info()[1]) + " Line: " + str(sys.exc_info()[2].tb_lineno))
                QMessageBox.warning(self.dlgC, "Error", "Error en Busqueda")
        except requests.exceptions.ConnectionError:
            logging.info("Error en servidor")
            QMessageBox.warning(self.dlgC, "Error", "Servidor no disponible")
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            logging.warning("Error en busqueda: " + str(sys.exc_info()[0]) + str(sys.exc_info()[1]))
            QMessageBox.warning(self.dlgC, "Error", "Error en busqueda")


    def consultaItemClicked(self, item, no_error_message=False):
        try:
            dialog = self.dlgEOG if self.whichDialog == "EditObjetoGrafico" else (self.dlgC if self.whichDialog == "Consulta" else self.iface.mainWindow())

            # Hacer la consulta al servidor para obtener la geometr√≠a
            r = requests.get(url=self.URL + "objeto_geometry", data=json.dumps(item.data(32)),
                            headers={'Authorization': "Bearer {}".format(self.TOKEN)})

            if r and r.status_code == 200 and r.json()["x"] is not None and r.json()["y"] is not None:
                logging.info("Succesful Geometry Query")

                # Deseleccionar todas las entidades de todas las capas
                for l in [l["obj"] for l in self.layers if l["tipo"] != "oms"]:
                    l.removeSelection()
                
                print(f"Datos del item (item.data(32)): {item.data(32)}")
                # Obtener la capa correspondiente al item
                layerList = [l for l in self.layers if "tabla" in l and l["tabla"] == item.data(32)["capa"]]
                if not layerList:
                    return  # No hay capa que coincida, salir sin error
                layerData = layerList[0]
                layer = layerData["obj"]

                # Asegurar que la capa est√© visible
                layerTreeObj = QgsProject.instance().layerTreeRoot().findLayer(layer)
                layerTreeObj.setItemVisibilityChecked(True)

                # Obtener la geometr√≠a del resultado
                geometry = r.json()
                canvas = self.iface.mapCanvas()
                mapPoint = QgsPointXY(geometry["x"], geometry["y"])

                # Calcular el rect√°ngulo de selecci√≥n si hay un envelope
                if "envelope" in geometry:
                    envelope = geometry["envelope"]
                    env_points = re.split(",| ", re.search(r'(?<=^POLYGON\(\().+(?=\)\))', envelope).group(0))
                    x_extent = abs(float(env_points[0]) - float(env_points[4]))
                    y_extent = abs(float(env_points[1]) - float(env_points[5]))
                    rect = QgsRectangle(mapPoint.x() - x_extent * 1.3, mapPoint.y() - y_extent * 1.3,
                                        mapPoint.x() + x_extent * 1.3, mapPoint.y() + y_extent * 1.3)
                else:
                    scale = 32500
                    rect = QgsRectangle(mapPoint.x() - scale, mapPoint.y() - scale,
                                        mapPoint.x() + scale, mapPoint.y() + scale)

                # Obtener featids asociados al item
                featids = item.data(32).get('featids', [])

                if len(featids) == 1:
                    # M√©todo directo - solo buscar por featid
                    def select_single():
                        canvas.mapCanvasRefreshed.disconnect(select_single)
                        
                        featid = featids[0]
                        
                        # B√∫squeda simple por featid
                        expr = QgsExpression(f'"featid" = {featid}')
                        
                        # Recorrer hasta encontrar el primero
                        for feature in layer.getFeatures(QgsFeatureRequest(expr)):
                            layer.select(feature.id())
                            break  # Solo seleccionar el primero
                    
                    canvas.mapCanvasRefreshed.connect(select_single)

                elif len(featids) > 1:
                    # L√≥gica para seleccionar m√∫ltiples featids (m√°s robusta pero m√°s lenta)
                    def select_multiple():
                        canvas.mapCanvasRefreshed.disconnect(select_multiple)
                        # Seleccionar todas las entidades que coincidan con los featids
                        for featid in featids:
                            expr = QgsExpression(f'"featid" = {featid}')  # Ajustar seg√∫n el nombre de campo
                            it = layer.getFeatures(QgsFeatureRequest(expr))
                            for feature in it:
                                layer.select(feature.id())

                    # Conectar la selecci√≥n al refresco del canvas
                    canvas.mapCanvasRefreshed.connect(select_multiple)

                    # Ajustar el rect√°ngulo para hacer un "zoom out" cuando hay m√∫ltiples featids
                    if "envelope" in geometry:
                        # Ajustar el rect√°ngulo para un zoom out basado en el n√∫mero de featids
                        zoom_out_factor = 1.3 + (len(featids) * 0.1)  # Incrementa el factor basado en la cantidad de featids
                        rect = QgsRectangle(mapPoint.x() - x_extent * zoom_out_factor,
                                            mapPoint.y() - y_extent * zoom_out_factor,
                                            mapPoint.x() + x_extent * zoom_out_factor,
                                            mapPoint.y() + y_extent * zoom_out_factor)
                    else:
                        scale = 32500 * (1 + len(featids) * 0.1)  # Incrementar el zoom seg√∫n el n√∫mero de featids
                        rect = QgsRectangle(mapPoint.x() - scale, mapPoint.y() - scale,
                                            mapPoint.x() + scale, mapPoint.y() + scale)
                else:
                    logging.warning("No featids found in item")

                # Ajustar el canvas al rect√°ngulo calculado
                canvas.setExtent(rect)
                canvas.refresh()

            else:
                logging.warning("Error en query geometria: " + r.text)
                if not no_error_message:
                    QMessageBox.warning(dialog, "Error", "El objeto seleccionado no posee geometr√≠a")

        except requests.exceptions.ConnectionError:
            logging.info("Error en servidor")
            QMessageBox.warning(dialog, "Error", "Servidor no disponible")

        except (KeyboardInterrupt, SystemExit):
            raise

        except:
            logging.warning("Error en query geometria: " + str(sys.exc_info()[0]) + str(sys.exc_info()[1]) + "Line: " + str(sys.exc_info()[2].tb_lineno))
            QMessageBox.warning(dialog, "Error", "El objeto seleccionado no se corresponde con el selector de b√∫squeda actual")




    def consultaComboChanged(self):
        self.dlgC.setMaximumSize(self.smallerSizeC)
        self.dlgC.setMinimumSize(self.smallerSizeC)
        self.dlgC.resize(self.smallerSizeC)

    # ABM objetos graficos
    def finishedUpdateGeometryEOG(self, feature):
        self.waitMsg.done(0)
        asociar = self.dataEOG["asociar"]
        item = self.dlgEOG.resultsTable.currentItem().data(32)
        self.buscarObjetoABM()
        
        # Verificar si hay advertencia en la respuesta
        if hasattr(self, 'dataEOG') and self.dataEOG.get("advertencia"):
            QMessageBox.warning(
                self.dlgEOG,
                "Advertencia de Jurisdicci√≥n",
                f"La geometr√≠a fue {'asociada' if asociar else 'desasociada'} exitosamente, pero se advierte:\n\n{self.dataEOG['advertencia']}\n\nVerificar la operaci√≥n rrealizada."
            )
        else:
            QMessageBox.information(
                self.dlgEOG,
                "√âxito",
                f"Geometr√≠a {'asociada' if asociar else 'desasociada'} con √©xito.\n\nEl buscador puede demorar unos minutos en actualizarse."
            )
        if asociar: # Borrar objeto de capa de dibujo
            capa = item['capa']
            if capa in ["VW_PARCELAS_GRAF_ALFA_RURALES", "VW_PARCELAS_PRESCRIPCIONES", "VW_PARCELA_PH", "VW_UNIDADES_PARCELARIAS"]: # Fix 
                capa = "VW_PARCELAS_GRAF_ALFA"
            featureLayer = [l["obj"] for l in self.layers if l["fisico"] == f"DIBUJO:{capa}"][0]
            featureLayer.deleteFeatures([feature.id()])
            featureLayer.triggerRepaint()
        else:
            capa = item['capa']
            if capa in ["VW_PARCELAS_GRAF_ALFA_RURALES", "VW_PARCELAS_PRESCRIPCIONES", "VW_PARCELA_PH", "VW_UNIDADES_PARCELARIAS"]: # Fix 
                capa = "VW_PARCELAS_GRAF_ALFA"
            if capa == "VW_PARCELAS_GRAF_ALFA":
                message = QMessageBox(QMessageBox.Question,"Geometr√≠a desasociada", "¬øDesea copiar la geometr√≠a desasociada a la capa de dibujo correspondiente?",
                                      QMessageBox.Yes|QMessageBox.No, self.dlgEOG)
                message.buttons()[0].setText("Si") 
                reply = message.exec()
                if reply == QMessageBox.Yes:
                    featureLayer = [l["obj"] for l in self.layers if l["fisico"] == f"DIBUJO:{capa}"][0]
                    new_dibujo_feature = QgsFeature()
                    new_dibujo_geo = QgsGeometry().fromWkt(self.dataEOG["geometry"])
                    new_dibujo_feature.setGeometry(new_dibujo_geo)
                    featureLayer.dataProvider().addFeatures([new_dibujo_feature])
                    featureLayer.triggerRepaint()

        # ≈îefrescar capa WFS (pasa en asociar y desasociar)
        capa = item['capa']
        if capa in ["VW_PARCELAS_PH"]: #Fix for PH
            wfsLayer = [l["obj"] for l in self.layers if l["fisico"] == capa][0]
            wfsLayer.dataProvider().reloadData()
            wfsLayer.triggerRepaint()

    def failedUpdateGeometryEOT(self,message):
        self.waitMsg.done(0)
        
        if message == "db":
            asociar = self.dataEOG["asociar"]
            error_response = self.dataEOG["ERROR"]
            logging.warning(f"Error en {'asociado' if asociar else 'desasociado'} geometrico de objeto sin tramite: {error_response}")
            if type(error_response) is list:
                errores_parrafo = ""
                for e in error_response:
                    errores_parrafo += f"‚Ä¢ {e}\n"
                QMessageBox.warning(self.dlgEOG, "Error en validaci√≥n", errores_parrafo)
            else:
                QMessageBox.warning(self.dlgEOG, "Error", f"Error en {'asociado' if asociar else 'desasociado'} de geometr√≠a")

        if message == "server":
            QMessageBox.warning(self.dlgEOG, "Error", "Servidor no disponible")
        if message == "other_error":
            QMessageBox.warning(self.dlgEOG, "Error", "Error en servidor")



    def EOGdesasociarGeometria(self):
        print("Iniciando desasociaci√≥n...")
        
        # Obtener el √≠tem seleccionado y la capa
        item = self.dlgEOG.resultsTable.currentItem().data(32)
        capa = item['capa']
        if capa in ["VW_PARCELA_PH"]:
            capa = "VW_PARCELAS_GRAF_ALFA"
        
        print(f"Usando capa: {capa}")
        
        # Seleccionar feature en el mapa
        self.selectMapFeatureForDesasociar(capa)
    
    def selectMapFeatureForDesasociar(self, capa=""):
        search_layers = []
        for l in self.layers:
            if l["fisico"] == capa or l["fisico"] in ["VW_PARCELAS_SANEAR"]:
                search_layers.append(l["obj"])
        
        self.minimizeDialog(self.whichDialog)

        self.selectFeatureMsg = QgsMessageBarItem(
            "Seleccione un objeto de la capa correspondiente para desasociar, haciendo click con el mouse. Cuando lo haga, espere un momento dicho proceso. Tecla ESC para cancelar",
            level=Qgis.Info, duration=0
        )
        self.iface.messageBar().pushItem(self.selectFeatureMsg)
        
        # Conectar la herramienta de selecci√≥n de caracter√≠sticas del mapa
        canvas = self.iface.mapCanvas()
        self.mapTool = self.IdentifyTool(canvas, search_layers)
        canvas.setMapTool(self.mapTool)
        self.mapTool.found_feats.connect(self.featureSelectedForDesasociar)
        self.featSelDlg = True  # Permitir abortar la selecci√≥n con la tecla Esc
    
    def featureSelectedForDesasociar(self, features):
        """ Manejar el evento de selecci√≥n de un feature en la capa actual para desasociar """
        if not features:
            print("No se seleccion√≥ ninguna geometr√≠a.")
            return

        # Obtener el √≠tem seleccionado para acceder a los featids
        item = self.dlgEOG.resultsTable.currentItem().data(32)
        featids = item['featids']  # Obtener todos los featids del √≠tem seleccionado

        print(f"Feats disponibles para desasociar: {featids}")
        cantidad = len(features)
        print(f"Cantidad de features seleccionados: {cantidad}")

        # Iterar sobre los features seleccionados
        for feature in features:
            # Obtener el featid del feature seleccionado
            feature_featid = feature.attribute('featid')

            # Aseg√∫rate de que el featid sea un entero para la comparaci√≥n
            if feature_featid is not None:
                feature_featid = int(feature_featid)

                # Verificar si el featid est√° en la lista de featids
                if feature_featid in featids:
                    self.abortFeatureSelect()
                    self.EOGupdateGeometria(asociar=False, feature=feature)
                    return
        
    def EOGupdateGeometria(self, asociar = True, feature = None):
        item = self.dlgEOG.resultsTable.currentItem().data(32)
        print(f"Datos del √≠tem seleccionado: {item}")
        if feature is not None:
            try:
                feature_featid = feature.attribute('featid')
                print(f"Feature seleccionado: {int(feature_featid)}")
            except:
                print(f"Feature sin featid, usando id: {item["id"]}")
                feature_featid = item["id"]
        if item['capa'] == 'VW_UNIDADES_PARCELARIAS':
            tabla_grafica = 'inm_unidad_parcelaria'
        else:
            # Para parcelas normales, usar el dato_tablagrafica si existe
            tabla_grafica = item.get('dato_tablagrafica', 'inm_unidad_parcelaria')
        message = QMessageBox(QMessageBox.Question, f"{'Asociaci√≥n' if asociar else 'Desasociaci√≥n'} de geometr√≠a", 
            f"¬øEst√° seguro de que desea {'asociar la geometr√≠a elegida al' if asociar else 'desasociar la geometr√≠a del'} objeto seleccionado?"
            f"\nObjeto seleccionado: \nTipo: {item['tipo']}\nNombre: {item['nombre']}\nDescripci√≥n: {item['descripcion']}",
            QMessageBox.Yes|QMessageBox.No, self.dlgEOG)
        message.buttons()[0].setText("Si") 
        reply = message.exec()
        if reply == QMessageBox.Yes:
            print(f"Usuario confirm√≥ {'asociar' if asociar else 'desasociar'} geometr√≠a.")
            if item.get("featids", False):
                item["featids"] = [int(feature_featid)]
            item["geometry"] = feature.geometry().asWkt() if asociar else "NULL"
            item["dato_tienegeom"] = "TRUE" if asociar else "FALSE"
            item["hostname"] = platform.uname()[1]
            item["dato_tablagrafica"] = tabla_grafica
            self.waitMsg = self.messageWait("Espere mientras se procesa el cambio...")
            thread = self.ServerLoaderUpdateGeometryEOG(self, item, asociar)
            print(f"Iniciando hilo para {'asociar' if asociar else 'desasociar'} geometr√≠a.")
            # S509 - Control de Huecos en Asociacion de parcelas - 
            if item['dato_tablagrafica'] in ['inm_parcela_grafica', 'inm_unidad_parcelaria'] and asociar and item['capa'] not in ["VW_PARCELAS_PRESCRIPCIONES"]: 
                layer_parcelas = [lay["obj"] for lay in self.layers if lay["fisico"] in ["VW_PARCELAS_GRAF_ALFA", "VW_PARCELAS_GRAF_ALFA_RURALES"]]
                geom_principal = feature.geometry().snappedToGrid(0.0001, 0.0001)
                buffer_geom = geom_principal.buffer(0.5, 5)  # Para detectar vecinos cercanos
                vecinos_geom = []

                # Recolectar geometr√≠as vecinas
                for layer in layer_parcelas:
                    for f in layer.getFeatures(QgsFeatureRequest().setFilterRect(buffer_geom.boundingBox())):
                        geom = f.geometry()
                        if geom and geom.isGeosValid() and geom.intersects(buffer_geom) or geom.overlaps(buffer_geom) or geom.contains(buffer_geom) or geom.within(buffer_geom):
                            vecinos_geom.append(geom.snappedToGrid(0.0001, 0.0001))  # Snap tambi√©n a los vecinos

                # Uni√≥n total de geometr√≠as (vecinos + principal)
                geometr√≠a_total = QgsGeometry.unaryUnion([geom_principal] + vecinos_geom)

                # Crear envolvente c√≥ncava (si falla, usar convexa)
                try:
                    envolvente = geometr√≠a_total.concaveHull(0.98, False)
                except Exception:
                    envolvente = geometr√≠a_total.convexHull()

                # Buffers para compensar errores de borde
                envolvente_buffer = envolvente.buffer(0.001, 5)
                union_buffer_neg = geometr√≠a_total.buffer(-0.001, 5)

                # Diferencia entre buffers para detectar huecos externos
                huecos_geom = envolvente_buffer.difference(union_buffer_neg)

                # Dividir huecos externos individuales
                huecos_individuales = []
                if not huecos_geom.isEmpty():
                    if huecos_geom.isMultipart() or huecos_geom.wkbType() == QgsWkbTypes.GeometryCollection:
                        partes = huecos_geom.asGeometryCollection()
                        for g in partes:
                            if g.area() > 0.01:
                                huecos_individuales.append(g)
                    else:
                        if huecos_geom.area() > 0.01:
                            huecos_individuales.append(huecos_geom)

                # Agregar huecos internos (anillos)
                anillos_internos = []
                if geom_principal.isMultipart():
                    poligonos = geom_principal.asMultiPolygon()
                    for poly in poligonos:
                        for ring in poly[1:]:  # omitir exterior
                            g = QgsGeometry.fromPolygonXY([ring])
                            if g.area() > 0.01:
                                anillos_internos.append(g)
                else:
                    pol = geom_principal.asPolygon()
                    for ring in pol[1:]:  # omitir exterior
                        g = QgsGeometry.fromPolygonXY([ring])
                        if g.area() > 0.01:
                            anillos_internos.append(g)

                # Unir todos los huecos detectados
                todos_los_huecos = huecos_individuales + anillos_internos

                # Analizar los huecos como en la API
                for h in todos_los_huecos:
                    if h.isEmpty() or h.area() <= 0.01:
                        continue

                    # M√©tricas geom√©tricas
                    area = h.area()
                    perimetro = h.length()
                    bbox = h.boundingBox()
                    largo = bbox.width()
                    ancho = bbox.height()
                    proporcion = largo / ancho if ancho != 0 else 0
                    concavidad = h.convexHull().area() / h.area() if h.area() != 0 else 1
                    valido = h.isGeosValid()

                    # V√©rtices
                    if h.isMultipart():
                        multipol = h.asMultiPolygon()
                        num_vertices = sum(len(ring) for poly in multipol for ring in poly)
                    else:
                        pol = h.asPolygon()
                        num_vertices = len(pol[0]) if pol else 0

                    # Condiciones sospechosas (ajuste m√°s fino)
                    condiciones_sospechosas = 0

                    # Umbrales moderados (ni tan bajos como antes, ni tan altos como los que filtraban todo)
                    if concavidad > 1700:    # Captura ambos ‚Üí suma para los dos, el del hueco suele ser mucho mayor
                        condiciones_sospechosas += 1
                    if num_vertices > 24:    # Suelen tener muchos m√°s v√©rtices
                        condiciones_sospechosas += 1
                    if proporcion > 2.0:     # El que tiene hueco suele ser menos al que no tiene
                        condiciones_sospechosas += 1
                    if perimetro > 145:      # Puede variar
                        condiciones_sospechosas += 1
                    if not valido:           # Ambos v√°lidos ‚Üí no suma
                        condiciones_sospechosas += 1

                    # Este punto es la clave:
                    # - Verdadero: condiciones >= 1 (concavidad y v√©rtices), √°rea = 0.14 ‚ùå
                    # - Falso: condiciones = 3 (concavidad, v√©rtices, per√≠metro), √°rea > 1 ‚úÖ

                    # Se reporta solo si:
                    # - Tiene al menos 1 condicion sospechosa Y
                    # - √Årea es mayor a 1 (evita falsos positivos grandes)
                    if condiciones_sospechosas >= 1 and area > 1:
                        self.selectFeatureMsg = QgsMessageBarItem(
                            "ATENCION: El objeto seleccionado est√° generando un espacio visible en la gr√°fica porque no se ajusta a su lindera, revisar si hay que corregir el dibujo o la lindera.",
                            level=Qgis.Warning,
                            duration=0
                        )
                        self.iface.messageBar().pushItem(self.selectFeatureMsg)
            thread.finished.connect(lambda: self.finishedUpdateGeometryEOG(feature))
            thread.failed.connect(self.failedUpdateGeometryEOT)
            thread.start() 

    def EOGasociarGeometria(self):
            item = self.dlgEOG.resultsTable.currentItem().data(32)
            capa = item['capa']
            if capa in ["VW_PARCELAS_GRAF_ALFA_RURALES", "VW_PARCELAS_PRESCRIPCIONES", "VW_PARCELA_PH"]: # Fix for VW_PARCELAS_GRAF_ALFA_RURALES y PRESCRIPCIONES
                capa = "VW_PARCELAS_GRAF_ALFA"
            self.selectMapFeatureByClick(capa = f"DIBUJO:{capa}")
    
    def buttonsToggleABM(self,asociar = False, desasociar = False):
        self.dlgEOG.buttonAsociar.setEnabled(asociar)
        self.dlgEOG.buttonDesasociar.setEnabled(desasociar)
    
    def EOGresultsTableItemSelected(self):
        if self.dlgEOG.resultsTable.currentItem() is not None:
            has_geometry = self.dlgEOG.resultsTable.currentItem().data(32)["dato_tienegeom"] == "TRUE" if isinstance(self.dlgEOG.resultsTable.currentItem().data(32)["dato_tienegeom"], str) else bool(self.dlgEOG.resultsTable.currentItem().data(32)["dato_tienegeom"])
            self.buttonsToggleABM(not has_geometry, has_geometry)

    def buscarObjetoABM(self):
        mostrados = 0
        self.dlgEOG.resultsTable.clearSelection()
        self.dlgEOG.resultsTable.setRowCount(0)
        self.dlgEOG.labelNoEncontrado.setVisible(False)
        self.dlgEOG.labelResultados.setVisible(False)
        self.buttonsToggleABM()
        try:
            r = requests.get(url=self.URL + "search_ABM", data=json.dumps({"search_terms": self.dlgEOG.lineBuscar.text(), "tipo": self.dlgEOG.comboObjeto.currentText().lower()}),
                            headers={'Authorization': "Bearer {}".format(self.TOKEN)})
            if r and r.status_code == 200:
                logging.info("Successful search request")
                total_docs = int(r.json()["response"]["numFound"])
                docs = r.json()["response"]["docs"]
                rows = int(r.json()["responseHeader"]["params"]["rows"])
                if len(docs) > 0:
                    for d in docs:
                        # Manejo del objeto dependiendo del tipo
                        if self.dlgEOG.comboObjeto.currentText().lower() not in ['parcelas', 'prescripciones']:
                            d['dato_tienegeom'] = d.get('dato_tienegeom') == "TRUE" if d.get('dato_tienegeom') else bool(d.get('featids'))
                            d['descripcion'] = re.sub(r'<br>', "\n", d['descripcion'])

                            # Verifica si hay featids
                            featids_value = d['featids'] if 'featids' in d else ['']  # Si no hay featids, crea una lista vac√≠a

                            # Repite la fila por cada featid
                            for featid in featids_value:
                                self.dlgEOG.resultsTable.insertRow(self.dlgEOG.resultsTable.rowCount())
                                items = []

                                # Crear nuevas instancias de QTableWidgetItem para cada columna
                                item_icon = QTableWidgetItem(QIcon(os.path.join(self.current_dir, 'icons/ok.png')) if d['dato_tienegeom'] else QIcon(os.path.join(self.current_dir, 'icons/cancel.png')), "")
                                item_nombre = QTableWidgetItem(f"{d['nombre'] if 'nombre' in d else ''}{'-' if 'nombre' in d and 'dato_nomenclatura' in d else ''}{d['dato_nomenclatura'] if 'dato_nomenclatura' in d else ''}")
                                item_descripcion = QTableWidgetItem(d['descripcion'])
                                item_featid = QTableWidgetItem(str(featid))

                                # A√±adir los items a la lista de items
                                items.append(item_icon)
                                items.append(item_nombre)
                                items.append(item_descripcion)
                                items.append(item_featid)

                                mostrados += 1

                                # Aplicar formato y asociar los datos para cada item
                                for i in range(4):  # Aumenta el rango para incluir featids
                                    font = items[i].font()
                                    font.setPointSize(10)
                                    items[i].setFont(font)
                                    items[i].setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable)
                                    items[i].setData(32, d)  # Asegurarse de que cada item tenga los datos asociados

                                    # A√±adir el item a la tabla
                                    self.dlgEOG.resultsTable.setItem(self.dlgEOG.resultsTable.rowCount() - 1, i, items[i])

                        else:
                            # Manejo para parcelas y prescripciones
                            if str(d['descripcion'])[str(d['descripcion']).find('Superficie') + 12: str(d['descripcion']).find('Superficie') + 15] > '0 m2':
                                d['dato_tienegeom'] = d.get('dato_tienegeom') == "TRUE" if d.get('dato_tienegeom') else bool(d.get('featids'))
                                d['descripcion'] = re.sub(r'<br>', "\n", d['descripcion'])

                                # Verifica si hay featids
                                featids_value = d['featids'] if 'featids' in d else ['']  # Si no hay featids, crea una lista vac√≠a

                                # Repite la fila por cada featid
                                for featid in featids_value:
                                    self.dlgEOG.resultsTable.insertRow(self.dlgEOG.resultsTable.rowCount())
                                    items = []

                                    # Crear nuevas instancias de QTableWidgetItem para cada columna
                                    item_icon = QTableWidgetItem(QIcon(os.path.join(self.current_dir, 'icons/ok.png')) if d['dato_tienegeom'] else QIcon(os.path.join(self.current_dir, 'icons/cancel.png')), "")
                                    item_nombre = QTableWidgetItem(f"{d['nombre'] if 'nombre' in d else ''}{'-' if 'nombre' in d and 'dato_nomenclatura' in d else ''}{d['dato_nomenclatura'] if 'dato_nomenclatura' in d else ''}")
                                    item_descripcion = QTableWidgetItem(d['descripcion'])
                                    item_featid = QTableWidgetItem(str(featid))

                                    # A√±adir los items a la lista de items
                                    items.append(item_icon)
                                    items.append(item_nombre)
                                    items.append(item_descripcion)
                                    items.append(item_featid)

                                    mostrados += 1

                                    # Aplicar formato y asociar los datos para cada item
                                    for i in range(4):  # Aumenta el rango para incluir featids
                                        font = items[i].font()
                                        font.setPointSize(10)
                                        items[i].setFont(font)
                                        items[i].setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable)
                                        items[i].setData(32, d)  # Asegurarse de que cada item tenga los datos asociados

                                        # A√±adir el item a la tabla
                                        self.dlgEOG.resultsTable.setItem(self.dlgEOG.resultsTable.rowCount() - 1, i, items[i])

                    if total_docs > rows:
                        self.dlgEOG.labelResultados.setVisible(True)
                        self.dlgEOG.labelResultados.setText(f"Mostrando {mostrados} de {total_docs - (len(docs) - mostrados)} resultados. Para una mejor precisi√≥n, ajuste el filtro ingresado.")
                    if len(docs) == 1 and self.dlgEOG.comboObjeto.currentText().lower() != 'parcelas':
                        self.consultaItemClicked(items[0], no_error_message=True)
                    if len(docs) == 1 and self.dlgEOG.comboObjeto.currentText().lower() == 'parcelas':
                        if str(d['descripcion'])[str(d['descripcion']).find('Superficie') + 12: str(d['descripcion']).find('Superficie') + 15] in ['0 m2', '0 ha']:
                            self.dlgEOG.labelNoEncontrado.setVisible(True)
                            self.dlgEOG.labelResultados.setVisible(False)
                        else:
                            self.consultaItemClicked(items[0], no_error_message=True)
                else:
                    self.dlgEOG.labelNoEncontrado.setVisible(True)
                    self.dlgEOG.labelResultados.setVisible(False)
            else:
                logging.warning("Error en busqueda: " + str(sys.exc_info()[0]) + str(sys.exc_info()[1]))
                QMessageBox.warning(self.dlgEOG, "Error", "Error en Busqueda")
        except requests.exceptions.ConnectionError:
            logging.info("Error en servidor")
            QMessageBox.warning(self.dlgEOG, "Error", "Servidor no disponible")
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            logging.warning("Error en busqueda: " + str(sys.exc_info()[0]) + str(sys.exc_info()[1]))
            QMessageBox.warning(self.dlgEOG, "Error", "No se pueden asociar o desasociar parcelas sin superficie") 

    """
        RUN METHODS
    """  
    def runChangePass(self):
        self.whichDialog = "ChangePass"
        self.toggleEnableToolbarIcons(False)
        if self.first_start_ChangePass == True:
            self.first_start_ChangePass = False
            self.dlgPass = PassDialog()
            # Events
            self.dlgPass.closed.connect(self.toggleEnableToolbarIcons)
            self.dlgPass.rejected.connect(self.toggleEnableToolbarIcons)
            self.dlgPass.accepted.connect(self.toggleEnableToolbarIcons)
            self.dlgPass.lineEdit_pw_2.textChanged.connect(self.unfocusedChangePass)
            self.dlgPass.lineEdit_pw_1.textChanged.connect(self.unfocusedChangePass)

        self.dlgPass.lineEdit_pw_1.setText("")
        self.dlgPass.lineEdit_pw_2.setText("")
        self.dlgPass.pushButton.setEnabled(False)
        self.dlgPass.show()
        result = self.dlgPass.exec_()

        if result:
            data = {'id' : self.user_data['Id_Usuario'],
                    'pass': hashlib.md5(self.dlgPass.lineEdit_pw_1.text().encode("utf-8")).hexdigest()}
            self.waitMsg = self.messageWait("Espere mientras se procesa el cambio...")
            thread = self.ServerLoaderChangePass(self, data)
            thread.finished.connect(self.finishedChangePass)
            thread.failed.connect(self.failedChangePass)
            thread.start() 


    def BTtableHeaderClick(self,index):
        columns = ["id_tramite","numero","tipo","objeto","prioridad","fecha_venc"]
        column_to_sort = columns[index]
        self.dataBT["tramites"].sort(key = lambda f: str(f[column_to_sort]) if column_to_sort != "id_tramite" else f[column_to_sort],reverse = self.lastSortedColumnBT is not None)
        self.lastSortedColumnBT = column_to_sort if self.lastSortedColumnBT is None else None
        self.finishedBandejaTramites()


    def runBandeja(self):
        try:
            self.toggleEnableToolbarIcons(False)
            # Limpiar si el di√°logo ya existe
            if not self.first_start_BT:
                self.cleanupBandeja()
            if self.first_start_BT:
                self.first_start_BT = False
                self.dlgBT = BandejaDialog()
                # Bloquear el redimensionamiento por parte del usuario
                self.dlgBT.setMaximumSize(self.dlgBT.size())
                self.dlgBT.setMinimumSize(self.dlgBT.size())
                self.defaultSizeBT = self.dlgBT.size()
                # Centrar el di√°logo en la pantalla
                self.dlgBT.setGeometry(
                    int((QDesktopWidget().screenGeometry().width() / 2) - (self.defaultSizeBT.width() / 2)),
                    int((QDesktopWidget().screenGeometry().height() / 2) - (self.defaultSizeBT.height() / 2)),
                    self.defaultSizeBT.width(),
                    self.defaultSizeBT.height()
                    )
                # Configuraci√≥n de la tabla
                self.dlgBT.tableTramites.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
                self.dlgBT.tableTramites.horizontalHeader().setVisible(True)  # Asegurar que el encabezado sea visible
                # Conexi√≥n de eventos
                self.dlgBT.closed.connect(self.toggleEnableToolbarIcons)
                self.dlgBT.rejected.connect(self.toggleEnableToolbarIcons)
                self.dlgBT.prevButton.clicked.connect(lambda: self.changeBandejaPage("prev"))
                self.dlgBT.nextButton.clicked.connect(lambda: self.changeBandejaPage("next"))
                self.dlgBT.reloadButton.clicked.connect(lambda: self.changeBandejaPage("reload"))
                self.dlgBT.okButton.clicked.connect(self.procesarTramite)
                self.dlgBT.tableTramites.horizontalHeader().sectionClicked.connect(self.BTtableHeaderClick)
                self.securityBandejaTramite()
                self.bandejaPage = 0
                # Mostrar mensaje de espera
                self.waitMsg = self.messageWait("Espere mientras se carga la bandeja de tr√°mites...")
                # Crear y ejecutar el hilo del servidor
                thread = self.ServerLoaderBandejaTramites(self, self.bandejaPage)
                thread.finished.connect(self.finishedBandejaTramites)
                thread.failed.connect(self.failedBandejaTramites)
                thread.start()
        except Exception as e:
            # Registrar el error en el log
            logging.error("Error en Bandeja de Tr√°mite: {}".format(str(e)))
            # Notificar al usuario del error
            self.showErrorMessage(f"Se ha producido un error al ejecutar la bandeja de tr√°mites:\n{str(e)}")
            # Habilitar nuevamente los √≠conos de la barra de herramientas
            self.toggleEnableToolbarIcons(True)
    def cleanupBandeja(self):
        """Limpia el estado del di√°logo y libera recursos."""
        if self.dlgBT:
            self.dlgBT.close()
            self.dlgBT = None
        self.first_start_BT = True
    def showErrorMessage(self, message):
        """Mostrar un mensaje de error al usuario."""
        msg_box = QMessageBox()
        msg_box.setIcon(QMessageBox.Critical)
        msg_box.setText(message)
        msg_box.setWindowTitle("Error")
        msg_box.exec_()
        
    def runConsulta(self):
        """ Run method for Busqueda Dialog """
        self.whichDialog = "Consulta"
        self.toggleEnableToolbarIcons(False)
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start_Consulta == True:
            self.first_start_Consulta = False
            self.dlgC = ConsultaDialog()
            self.defaultSizeC = self.dlgC.size()
            self.smallerSizeC = QSize(self.defaultSizeC.width(),134)
            # Events
            self.dlgC.closed.connect(self.toggleEnableToolbarIcons)
            self.dlgC.rejected.connect(self.toggleEnableToolbarIcons)
            self.dlgC.buttonSearch.clicked.connect(self.performConsulta)
            self.dlgC.resultsTable.itemDoubleClicked.connect(self.consultaItemClicked)
            self.dlgC.resultsTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
            self.dlgC.resultsTable.horizontalHeader().setVisible(True) # only because QT Designer keeps setting this to False
            self.dlgC.comboObjeto.currentIndexChanged.connect(self.consultaComboChanged)

        # Lock resizing for user
        self.dlgC.setMaximumSize(self.smallerSizeC)
        self.dlgC.setMinimumSize(self.smallerSizeC)
        self.dlgC.setGeometry(int((QDesktopWidget().screenGeometry().width() / 2) - (self.smallerSizeC.width() / 2)),int((QDesktopWidget().screenGeometry().height() / 2) - (self.smallerSizeC.height() / 2)),self.smallerSizeC.width(),self.smallerSizeC.height())
        # Hide results label
        self.dlgC.labelNoEncontrado.setVisible(False)
        self.dlgC.labelResultados.setVisible(False)
        # clear search
        self.dlgC.lineSearch.clear()
        self.dlgC.show()

    def runEditObjetosGraficos(self):
        """ Run method for Edit Objetos Graficos Dialog """
        self.whichDialog = "EditObjetoGrafico"
        self.toggleEnableToolbarIcons(False)
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start_EditObjetoGrafico == True:
            self.first_start_EditObjetoGrafico = False
            self.dlgEOG = EditObjetoGraficoDialog()
            self.defaultSizeEOG = self.dlgEOG.size()
            # Lock resizing for user
            self.dlgEOG.setMaximumSize(self.defaultSizeEOG)
            self.dlgEOG.setMinimumSize(self.defaultSizeEOG)
            self.dlgEOG.setGeometry(int((QDesktopWidget().screenGeometry().width() / 2) - (self.defaultSizeEOG.width() / 2)),int((QDesktopWidget().screenGeometry().height() / 2) - (self.defaultSizeEOG.height() / 2)),self.defaultSizeEOG.width(),self.defaultSizeEOG.height())
            # Table config
            self.dlgEOG.resultsTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
            self.dlgEOG.resultsTable.horizontalHeader().setVisible(True) # only because QT Designer keeps setting this to False
            self.dlgEOG.resultsTable.itemSelectionChanged.connect(self.EOGresultsTableItemSelected)
            self.dlgEOG.resultsTable.itemDoubleClicked.connect(self.consultaItemClicked)
            # Events
            self.dlgEOG.closed.connect(self.toggleEnableToolbarIcons)
            self.dlgEOG.rejected.connect(self.toggleEnableToolbarIcons)
            self.dlgEOG.buttonBuscar.clicked.connect(self.buscarObjetoABM)
            self.dlgEOG.buttonAsociar.clicked.connect(self.EOGasociarGeometria)
            self.dlgEOG.buttonDesasociar.clicked.connect(self.EOGdesasociarGeometria)
        
        self.securityABMObjetosGraficos()
        self.dlgEOG.lineBuscar.clear() # Clear search

        # Set combo/widget to parcela
        self.dlgEOG.comboObjeto.setCurrentIndex(0)
        # Hide label
        self.dlgEOG.labelNoEncontrado.setVisible(False)
        self.dlgEOG.labelResultados.setVisible(False)
        # Clear searchlist
        self.dlgEOG.resultsTable.clearSelection()
        self.dlgEOG.resultsTable.setRowCount(0)
        # Disable buttons
        self.buttonsToggleABM()
        # Show dialog
        self.dlgEOG.show()

    def runLogin(self):
        self.whichDialog = "Login"
        self.toggleEnableToolbarIcons(False)
        if self.first_start_Login == True:
            self.first_start_Login = False
            self.dlgLG = LoginDialog()
            # Lock resizing for user
            self.dlgLG.setMaximumSize(self.dlgLG.size())
            self.dlgLG.setMinimumSize(self.dlgLG.size())
            self.defaultSizeLG = self.dlgLG.size()
            self.dlgLG.setGeometry(int((QDesktopWidget().screenGeometry().width() / 2) - (self.defaultSizeLG.width() / 2)),int((QDesktopWidget().screenGeometry().height() / 2) - (self.defaultSizeLG.height() / 2)),self.defaultSizeLG.width(),self.defaultSizeLG.height())
            # Event handlers
            self.dlgLG.closed.connect(self.toggleEnableToolbarIcons)
            self.dlgLG.rejected.connect(self.toggleEnableToolbarIcons)
            self.dlgLG.buttonLogin.clicked.connect(self.attemptLogin)
            self.dlgLG.buttonSuperLogin.clicked.connect(lambda: self.attemptLogin(super = True))

        # Hide button
        #self.dlgLG.buttonSuperLogin.setVisible(False)
        # show the dialog
        self.dlgLG.show()

