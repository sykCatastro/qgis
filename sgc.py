# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SGC
                                 A QGIS plugin
 Sistema Integral de Gestión Catastral
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-12-15
        git sha              : $Format:%H$
        copyright            : (C) SyK Catastro Sistemas
        email                : sykcatastro.sistemas@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QSize, QThread, pyqtSignal, pyqtSlot, QObject, QItemSelectionModel, QAbstractItemModel, QModelIndex, QUrl,QPoint
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from qgis.PyQt.QtXml import *
from qgis.core import *
from qgis.gui import QgsMapToolIdentify, QgsLayerTreeView, QgsMessageBarItem, QgsMapToolEmitPoint, QgsMapTool, QgsMapToolIdentifyFeature
from PyQt5.QtCore import QAbstractTableModel, QVariant, Qt, QDateTime, QStringListModel, QSortFilterProxyModel, QEvent, QMetaMethod
from datetime import date, datetime
from pathlib import Path
import requests, re, hashlib, json, logging.config, time, math, copy, os.path, sys, base64, platform, glob
import locale as locale_lib

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .bandeja_dialog import BandejaDialog
from .login_dialog import LoginDialog
from .pass_dialog import PassDialog
from .edit_tramite_dialog import EditTramiteDialog
from .doc_info_dialog import DocInfoDialog
from .consulta_dialog import ConsultaDialog
from .edit_objeto_grafico_dialog import EditObjetoGraficoDialog

class SGC:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'SGC_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Sistema Integral de Gestión Catastral')

        # Properties
        self.actions = []
        self.user_actions = []
        self.first_start_BT = True
        self.first_start_Login = True
        self.first_start_ChangePass = True
        self.first_start_EditTramite = True
        self.first_start_DocInfo = True
        self.first_start_Consulta = True
        self.first_start_EditObjetoGrafico = True
        # Data for login/pass change
        self.passChange = False
        self.dataBT = None
        self.lastSortedColumnBT = None
        # Data for Edit Tramite
        self.ETtabDatosEspecificos = False
        self.dataET = None
        # Data for ABM Objetos Gráficos
        self.dataEOG = None
        # List of SGC Layers 
        self.layers = []
        self.dataLayers = None
        # Data for edit tramite
        self.tramiteGroupString =  ""
        # Data for icons for the entire application
        self.current_dir = os.path.dirname(os.path.realpath(__file__))
        # Dialog data for feature selection
        self.dialogs = {"EditTramite": [["dlgET","defaultSizeET"]],
                        "dlgBT": [["dlgBT","defaultSizeBT"]],
                        "dlgET": [["dlgET","defaultSizeET"]],
                        "EditObjetoGrafico": [["dlgEOG","defaultSizeEOG"]],
                        "Consulta": [["dlgC","defaultSizeC"]]}
        # Initialization functions
        self.configFromFile()

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('SGC', message)


    def add_action(
        self,
        icon_path,
        text,
        callback=None,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
        add_to_user_toolbar=False):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        if callback: action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar and not add_to_user_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_user_toolbar:
            # Adds action to logged in user toolbar
            self.user_toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToWebMenu(
                self.menu,
                action)

        if not add_to_user_toolbar:
            self.actions.append(action)
        else:
            self.user_actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        icon_path = ':/plugins/sgc/icon.png'
        login_icon_path = os.path.join(self.current_dir,'icons/login.png')
        # Login Dialog Icon
        self.add_action(
            login_icon_path,
            text=self.tr(u'SGC Login'),
            callback=self.runLogin,
            parent=self.iface.mainWindow())

        # Initiate Logger
        logging.getLogger('PyQt5').setLevel(logging.CRITICAL)
        logging.getLogger('requests').setLevel(logging.CRITICAL)
        logging.basicConfig(format='%(asctime)s - %(message)s',filename=os.path.join(Path.home(),'sgc.log'),level=logging.DEBUG)
        logging.debug("Plugin iniciado")
        # For Esc key connection
        self.shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self.iface.mainWindow())
        self.shortcut.setContext(Qt.ApplicationShortcut)
        self.shortcut.activated.connect(self.escPressed)
        self.featSelDlg = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Sistema Integral de Gestión Catastral'),
                action)
            self.iface.removeToolBarIcon(action)
        self.logout(True)


    def logout(self, skip_question = False):
        if not skip_question:
            message = QMessageBox(QMessageBox.Question, "Cerrar sesión", "¿Está seguro de que desea cerrar la sesión actual?",
                QMessageBox.Yes|QMessageBox.No, self.iface.mainWindow())
            message.buttons()[0].setText("Si") 
            reply = message.exec()
        else:
            reply = QMessageBox.Yes
        if reply == QMessageBox.Yes:
            # Menus, toolbars, and UI elements
            if self.iface.mainWindow().findChild(QToolBar, "SGC"):
                toolbar = self.iface.mainWindow().findChild(QToolBar, "SGC")
                # This removes the toolbar but doesn't delete it
                self.iface.mainWindow().removeToolBar(toolbar)
                # This deletes it
                toolbar.setParent(None)
                self.user_actions = []
                # Show Login/Other buttons once again
                for action in self.actions:
                    action.setVisible(True)
            # Logs and notifications
            if hasattr(self, 'user_data') and hasattr(self.user_data, 'Id_Usuario'):
                self.iface.messageBar().pushMessage("Sesión cerrada", "Cerrada sesión de usuario ",level=Qgis.Success, duration=3)
                logging.info("Cerrada sesión de usuario " +
                    str(self.user_data['Id_Usuario']) + " - " +
                    str(self.user_data['Nombre']) + " " +
                    str(self.user_data['Apellido']))
                # Data
                self.user_data = None
                self.TOKEN = None
                self.funciones = None
            # Remove layers from map
            if hasattr(self, 'dataLayers') and self.dataLayers is not None and "grupos" in self.dataLayers:
                # Just in case, remove temporarily added group
                self.loadTramiteLayerGroup(True)
                # Remove groups/layers from database
                for g in self.dataLayers["grupos"]:
                    root = QgsProject.instance().layerTreeRoot()
                    group = root.findGroup(g["nombre"])
                    if group is not None:
                        for child in group.children():
                            if isinstance(child,QgsLayerTreeGroup):
                                root.removeChildNode(child)
                            else:
                                QgsProject.instance().removeMapLayer(child.layerId())
                        root.removeChildNode(group)
                # Remove "Dibujos" group
                group = root.findGroup("Dibujos")
                if group is not None:
                    for child in group.children():
                        if isinstance(child,QgsLayerTreeGroup):
                            root.removeChildNode(child)
                        else:
                            QgsProject.instance().removeMapLayer(child.layerId())
                    root.removeChildNode(group)
            self.layers = []
            self.dataLayers = None
            self.iface.mapCanvas().refresh()
    """
        Logged user toolbar functions and definitions
    """
    def enableToolBar(self,data_user):
        if not self.iface.mainWindow().findChild(QToolBar, "SGC"):
            logging.info("Añadida barra de herramientas de usuario")
            # Icons
            icon_path = ':/plugins/sgc/icon.png'
            #password_icon_path = os.path.join(self.current_dir,'icons/password.png')
            logout_icon_path = os.path.join(self.current_dir, 'icons/logout2.png')
            tray_icon_path = os.path.join(self.current_dir, 'icons/tray.png')
            consulta_icon_path = os.path.join(self.current_dir, 'icons/consulta.png')
            edit_objetos_graficos_icon_path = os.path.join(self.current_dir, 'icons/objetos_graficos.png')
            # Toolbar            
            self.user_toolbar = self.iface.addToolBar("SGC")
            self.user_toolbar.setObjectName("SGC")
            # Bandeja de Trámite
            if '502' in self.funciones: # "Bandeja de trámite"
                self.add_action(tray_icon_path,
                    text='Bandeja de trámites',
                    callback=self.runBandeja,
                    parent=self.user_toolbar,
                    add_to_user_toolbar=True)
            # Búsqueda/Consulta
            if '507' in self.funciones: # "Consulta Alfanumérica"
                self.add_action(consulta_icon_path,
                    text='Consulta Alfanumérica',
                    callback=self.runConsulta,
                    parent=self.user_toolbar,
                    add_to_user_toolbar=True)
            # ABM Objetos Gráficos
            if '508' in self.funciones: # "ABM Objetos Gráficos"
                self.add_action(edit_objetos_graficos_icon_path,
                    text='ABM Objetos Gráficos',
                    callback=self.runEditObjetosGraficos,
                    parent=self.user_toolbar,
                    add_to_user_toolbar=True)
            # Separator
            self.user_toolbar.addSeparator()
            # Login/Logout buttons
            self.add_action(
                icon_path="",
                text="Usuario: " + data_user["Nombre"] + " " + data_user["Apellido"],
                callback=None,
                parent=self.user_toolbar,
                add_to_user_toolbar=True)
            self.add_action(
                icon_path=logout_icon_path,
                text="Salir",
                callback=self.logout,
                parent=self.user_toolbar,
                add_to_user_toolbar=True)
            # Hide Login/Other buttons whenever we're logged in
            for action in self.actions:
                action.setVisible(False)
    """
        -------------
    """
    def configFromFile(self):
        """ Defaults to "http://localhost:5000/" if file not found or no URL in config file """
        config_dir = os.path.join(self.current_dir,'config.ini')
        self.URL = "http://localhost:5020/"
        try:
            with open(config_dir, 'r') as f:
                line_content = f.readline()
                while line_content:
                    URL = re.search('(?<=^URL=).*', line_content)
                    if URL:
                        self.URL = URL.group(0).strip()
                        break
                    line_content = f.readline()
        except IOError: pass

    def toggleEnableToolbarIcons(self, closing = True):
        if self.whichDialog == "EditTramite" and not closing:
            self.loadTramiteLayerGroup(True)
            self.maximizeDialog("dlgBT")
            self.dlgBT.activateWindow()
            return
        if closing:
            self.whichDialog = None # Dialog name is reset
        for a in self.actions:
            a.setEnabled(closing)
        for a in self.user_actions:
            a.setEnabled(closing)
        self.classType = None

    """

        SECURITY METHODS

    """
    def securityBandejaTramite(self):
        bandeja_logic = '503' in self.funciones and ('505' in self.funciones or ('504' in self.funciones and '506' in self.funciones)) # "Procesar trámite"  "Asociar geometrías" "Desasociar geometrías" "Validar trámite"
        self.dlgBT.okButton.setVisible(bandeja_logic)
        try: self.dlgBT.tableTramites.itemDoubleClicked.disconnect()
        except (KeyboardInterrupt, SystemExit): raise
        except: pass
        if bandeja_logic: self.dlgBT.tableTramites.itemDoubleClicked.connect(self.procesarTramite)

    def securityEditTramite(self):
        self.dlgET.asociarButton.setVisible('504' in self.funciones) # "Asociar Geometrías"
        self.dlgET.desasociarButton.setVisible('505' in self.funciones) # "Desasociar Geometrías"

    def securityABMObjetosGraficos(self):
        self.dlgEOG.buttonDesasociar.setVisible('509' in self.funciones) # "Eliminar gráfico"
        self.dlgEOG.buttonAsociar.setVisible('511' in self.funciones) # "Seleccionar nueva geometría"


    """

        ------

    """



    """
        THREADED WORKER NETWORK REQUESTS
    """
    class WaitMessage(QThread):
        #finished = pyqtSignal()
        #failed = pyqtSignal()
        def __init__(self, outer_self,message):
            self.outer = outer_self
            self.msg = None
            self.message = message
            super(SGC.WaitMessage, self).__init__(outer_self.iface)
        
        @pyqtSlot()
        def doneMessage(self):
            self.msg.done(0)

        def run(self):
            self.msg = QMessageBox()
            # Get path of .gif in plugin folder
            gif_path = os.path.join(self.outer.current_dir,'icons/cogs1.gif')
            # Create Label
            pixmap = QPixmap(gif_path)
            pixmap = pixmap.scaled(120,120,Qt.KeepAspectRatio)
            msg.setIconPixmap(pixmap)
            icon_label = self.msg.findChild(QLabel, "qt_msgboxex_icon_label")
            # Define gif
            movie = QMovie(gif_path)
            movie.setScaledSize(QSize(120,120))
            # Replace static image Icon with gif
            setattr(self.msg, 'icon_label', movie) # avoid garbage collector
            icon_label.setMovie(movie)
            movie.start()
            # Set window text and buttons
            self.msg.setWindowTitle("Cargando formulario...")
            self.msg.setModal(True)
            self.msg.setText(self.message if self.message != "" else "Espere mientras se carga el formulario...")
            self.msg.rejected.connect(self.msg.close)
            self.msg.setStandardButtons(QMessageBox.Cancel)
            self.msg.buttons()[0].setText("Cerrar")
            self.msg.show()
            return self.msg

    class ServerLoaderDBLayers(QThread):
        finished = pyqtSignal()
        failed = pyqtSignal()
        def __init__(self, outer_self):
            self.outer = outer_self
            super(SGC.ServerLoaderDBLayers, self).__init__(outer_self.iface)
        def run(self):
            try:
                r = requests.get(url = self.outer.URL + "layers", 
                                 headers={'Authorization': "Bearer {}".format(self.outer.TOKEN)})
                if r.status_code == 200:
                    self.outer.dataLayers = json.loads(r.text)
                    self.finished.emit()
                else:
                    logging.warning("Acceso no autorizado")
                    self.failed.emit()
            except requests.exceptions.ConnectionError:
                logging.warning("Error en servidor")
                self.failed.emit() # Close waiting dialog

    class ServerLoaderTramiteDatos(QThread):
        finished = pyqtSignal()
        failed = pyqtSignal(str)
        def __init__(self, outer_self,id_tramite):
            self.outer = outer_self
            self.id_tramite = int(id_tramite)
            super(SGC.ServerLoaderTramiteDatos, self).__init__(outer_self.iface)
        def run(self):
            try:
                r = requests.get(url = self.outer.URL + f"tramite/{self.id_tramite}",
                                 headers={'Authorization': "Bearer {}".format(self.outer.TOKEN)})
                result = json.loads(r.text)
                if r and r.status_code == 200 and 'ERROR' not in result:
                    self.outer.dataET = result
                    self.finished.emit()
                else:
                    self.failed.emit("db") 
            except requests.exceptions.ConnectionError:
                self.failed.emit("server")
            except (KeyboardInterrupt, SystemExit): raise
            except: self.failed.emit("server")
            
    class ServerLoaderBandejaTramites(QThread):
        finished = pyqtSignal()
        failed = pyqtSignal(str)
        def __init__(self, outer_self,page):
            self.outer = outer_self
            self.page = page
            super(SGC.ServerLoaderBandejaTramites, self).__init__(outer_self.iface)
        def run(self):
            try:
                r = requests.get(url = self.outer.URL + "tramite/all", #data = {"page": self.page},
                                 headers={'Authorization': "Bearer {}".format(self.outer.TOKEN)})
                result = json.loads(r.text)
                if r and r.status_code == 200 and 'ERROR' not in result:
                    self.outer.dataBT = result
                    self.finished.emit()
                else:
                    self.failed.emit("db") 
            except requests.exceptions.ConnectionError:
                self.failed.emit("server")
            except (KeyboardInterrupt, SystemExit): raise
            except: self.failed.emit("server")

    class ServerLoaderChangePass(QThread):
        finished = pyqtSignal()
        failed = pyqtSignal(str)
        def __init__(self, outer_self, data):
            self.outer = outer_self
            self.data = data
            super(SGC.ServerLoaderChangePass, self).__init__(outer_self.iface)
        def run(self):
            try:
                r = requests.post(url = self.outer.URL + "user/pass", data = self.data, 
                                 headers={'Authorization': "Bearer {}".format(self.outer.TOKEN)})
                result = json.loads(r.text)
                if r and r.status_code == 200 and 'ERROR' not in result:
                    self.finished.emit()
                else:
                    self.failed.emit("db") # Close waiting dialog
            except requests.exceptions.ConnectionError:
                self.failed.emit("server") # Close waiting dialog
            except (KeyboardInterrupt, SystemExit): raise
            except: self.failed.emit("server")

    class ServerLoaderLogin(QThread):
        finished = pyqtSignal()
        failed = pyqtSignal(str)
        pass_change_required = pyqtSignal()
        def __init__(self, outer_self, data):
            self.outer = outer_self
            self.data = data
            super(SGC.ServerLoaderLogin, self).__init__(outer_self.iface)
        def run(self):
            try:
                r = requests.post(url = self.outer.URL + "auth", data = self.data)
                self.outer.user_data = json.loads(r.text)
                if r and 'ERROR' not in self.outer.user_data and 'ERROR_PERMISOS' not in self.outer.user_data and "TIMEOUT" not in self.outer.user_data:
                    if self.outer.user_data['user']['Cambio_pass']:
                        self.pass_change_required.emit()
                    else:
                        self.finished.emit()
                else:
                    self.failed.emit("db") # Close waiting dialog
            except requests.exceptions.ConnectionError:
                self.failed.emit("server") # Close waiting dialog
            except (KeyboardInterrupt, SystemExit): 
                raise
            except:
                self.failed.emit("server")

    class ServerLoaderUpdateGeometryEOG(QThread):
        finished = pyqtSignal()
        failed = pyqtSignal(str)
        def __init__(self, outer_self, data, asociar):
            self.outer = outer_self
            self.data = data
            self.asociar = asociar
            super(SGC.ServerLoaderUpdateGeometryEOG, self).__init__(outer_self.iface)
        def run(self):
            try:
                r = requests.put(url = self.outer.URL + "objeto_geometry", data = json.dumps(self.data),headers={'Authorization': "Bearer {}".format(self.outer.TOKEN)})
                self.outer.dataEOG = r.json()
                self.outer.dataEOG["asociar"] = self.asociar
                if r.status_code == 200:
                    self.finished.emit()
                else:
                    self.failed.emit("db") # Close waiting dialog
            except requests.exceptions.ConnectionError:
                logging.warning("Error en servidor")
                self.failed.emit("server") # Close waiting dialog
            except (KeyboardInterrupt, SystemExit): 
                raise
            except:
                logging.warning("ERROR : " + str(sys.exc_info()[0]) + str(sys.exc_info()[1])  + str(sys.exc_info()[2]) + "Line: " + str(sys.exc_info()[2].tb_lineno))
                self.failed.emit("other_error")

    """
        GENERAL FUNCTIONS
    """
    def initialZoom(self):
        canvas = self.iface.mapCanvas()
        scale = self.dataLayers["initial_zoom"]["scale"]
        x = self.dataLayers["initial_zoom"]["x"]
        y = self.dataLayers["initial_zoom"]["y"]
        rect = QgsRectangle(x - scale, y - scale, x + scale, y + scale)
        canvas.setExtent(rect)
        canvas.refresh()

    class IdentifyTool(QgsMapTool):
        found_feats = pyqtSignal(list)
        def __init__(self, canvas, layers):
            QgsMapTool.__init__(self, canvas)
            self.canvas = canvas
            self.layers = layers

        def canvasPressEvent(self, event):
            QgsMapTool.canvasPressEvent(self, event)
            pos = self.toMapCoordinates(event.pos())
            result = []
            try:
                for layer in self.layers:
                    circle = QgsGeometry.fromPointXY(QgsPointXY(pos.x(),pos.y())).buffer(0.00001 if layer.name() != 'Localidades' else 2000,5)
                    features = layer.getFeatures()
                    for feat in features:
                        if circle.intersects(feat.geometry()) or circle.contains(feat.geometry()):
                            result.append(feat)
            except (KeyboardInterrupt, SystemExit): raise
            except: pass
            if len(result) > 0:
                self.found_feats.emit(result)

        def deactivate(self):
            try: # Have to use a try/except construct since disconnect() loves throwing exceptions
                self.canvas.unsetMapTool(self)
            except (KeyboardInterrupt, SystemExit): raise
            except: pass

    def abortFeatureSelect(self):
        try: self.selectFeatureMsg.dismiss()
        except (KeyboardInterrupt, SystemExit): raise
        except: pass

        self.maximizeDialog(self.whichDialog)
            
        #Remove feature selection event
        try: 
            self.mapTool.found_feats.disconnect()
            self.mapTool.deactivate()
        except (KeyboardInterrupt, SystemExit): raise
        except: pass
        self.featSelDlg = False

    def escPressed(self):
        if self.featSelDlg: self.abortFeatureSelect()

    def minimizeDialog(self,dialog = None):
        if dialog in self.dialogs:
            dialogs = self.dialogs[dialog]
            for d in dialogs:
                dlg = getattr(self,d[0],None)
                if dlg is not None:
                    dlg.setMinimumSize(0,0)
                    dlg.resize(0,0)

    def maximizeDialog(self,dialog = None):
        if dialog in self.dialogs:
            dialogs = self.dialogs[dialog]
            for d in dialogs:
                dlg = getattr(self,d[0],None)
                size = getattr(self,d[1],None)
                if dlg is not None:
                    dlg.setMaximumSize(size)
                    dlg.setMinimumSize(size)
                    dlg.resize(size)

    def selectMapFeatureByClick(self,capa = ""):
        search_layers = []
        for l in self.layers:
            if l["fisico"] == capa or l["fisico"] in ["vw_parcelas_sanear"]:
                search_layers.append(l["obj"])
        self.minimizeDialog(self.whichDialog)
        
        self.selectFeatureMsg = QgsMessageBarItem("Seleccione un objeto de la capa correspondiente al objeto a asociar, haciendo click con el mouse. Cuando lo haga, espere un momento dicho proceso. Tecla ESC para cancelar",level=Qgis.Info, duration=0)
        self.iface.messageBar().pushItem(self.selectFeatureMsg)
        # Connection with map feature selection tool
        canvas = self.iface.mapCanvas()
        self.mapTool = self.IdentifyTool(canvas, search_layers)
        canvas.setMapTool(self.mapTool)
        self.mapTool.found_feats.connect(self.featureSelected)
        self.featSelDlg = True # Allow to abort selection with Esc key

    def featureSelected(self, features):
        """ Trigger event for the selection of a polygon/feature in current layer """
        for f in features:
            feature = features[0]
        self.abortFeatureSelect()
        if self.whichDialog == "EditTramite":
            self.featureAsociadaET(feature)
        if self.whichDialog == "EditObjetoGrafico":
            self.EOGupdateGeometria(asociar = True, feature = feature)
    
 
    """
        --- END ---
    """


    """
        METHOD FUNCTIONS
    """
    # Wait dialog
    def messageWait(self, message = ""):
        """ Waiting dialog"""
        msg = QMessageBox()
        # Get path of .gif in plugin folder
        gif_path = os.path.join(self.current_dir,'icons/cogs1.gif')
        # Create Label
        pixmap = QPixmap(gif_path)
        pixmap = pixmap.scaled(120,120,Qt.KeepAspectRatio)
        msg.setIconPixmap(pixmap)
        icon_label = msg.findChild(QLabel, "qt_msgboxex_icon_label")
        # Define gif
        movie = QMovie(gif_path)
        movie.setScaledSize(QSize(120,120))
        # Replace static image Icon with gif
        setattr(msg, 'icon_label', movie) # avoid garbage collector
        icon_label.setMovie(movie)
        movie.start()
        # Set window text and buttons
        msg.setWindowTitle("Cargando formulario...")
        msg.setModal(True)
        msg.setText(message if message != "" else "Espere mientras se carga el formulario...")
        msg.rejected.connect(msg.close)
        msg.setStandardButtons(QMessageBox.Cancel)
        msg.buttons()[0].setText("Cerrar")
        msg.show()
        return msg

    # Change Password
    def unfocusedChangePass(self):
        if self.dlgPass.lineEdit_pw_1.text() != "" and self.dlgPass.lineEdit_pw_1.text() == self.dlgPass.lineEdit_pw_2.text():
            self.dlgPass.pushButton.setEnabled(True)
            self.dlgPass.pushButton.setToolTip("")
        else:
            self.dlgPass.pushButton.setEnabled(False)
            self.dlgPass.pushButton.setToolTip("Las contraseñas deben coincidir")
    
    def passChangeRequired(self):
        self.waitMsg.done(0)
        self.passChange = True
        self.funciones = self.user_data['funciones']
        self.TOKEN = self.user_data['TOKEN']
        self.user_data = self.user_data['user']
        QMessageBox.information(self.iface.mainWindow(), "Cambio de contraseña", "Debe cambiar de contraseña para completar el proceso de inicio de sesión")
        self.runChangePass()

    # Login
    def attemptLogin(self, super = False):
        self.superLogin = super
        data = {'user' : self.dlgLG.lineEdit_user.text(),
                'pass': hashlib.md5(self.dlgLG.lineEdit_pw.text().encode("utf-8")).hexdigest()}
        self.waitMsg = self.messageWait("Espere mientras se verifican sus datos...")
        thread = self.ServerLoaderLogin(self, data)
        thread.finished.connect(self.finishedLogin)
        thread.failed.connect(self.failedLogin)
        thread.pass_change_required.connect(self.passChangeRequired)
        thread.start()

    def finishedLogin(self): 
        self.waitMsg.done(0)
        self.waitMsg.close()
        self.funciones = self.user_data['funciones']
        self.TOKEN = self.user_data['TOKEN']
        self.user_data = self.user_data['user']
        logging.info('Usuario logueado: ' +
            str(self.user_data['Id_Usuario']) +
            " - " + str(self.user_data['Nombre']) +
            " " + str(self.user_data['Apellido']))
        self.iface.messageBar().pushMessage(
            "¡Éxito!", "Login exitoso",level=Qgis.Success, duration=3)
        self.enableToolBar(self.user_data)
        self.dlgLG.close()
        # After succesful login, attempt to bring up the DB Layers
        thread = self.ServerLoaderDBLayers(self)
        thread.finished.connect(self.loadDBLayers)
        thread.failed.connect(self.failedDBLayers)
        thread.start()

    def failedLogin(self, type):
        self.waitMsg.done(0)
        if type == "db" and self.user_data and 'ERROR' in self.user_data:
            logging.warning("Intento de login fallido")
            QMessageBox.warning(self.dlgLG, "Login Error", "Usuario o Contraseña inválidos")
        elif type == "db" and self.user_data and 'ERROR_PERMISOS' in self.user_data:
            QMessageBox.warning(self.dlgLG, "Login Error", "El usuario ingresado no posee permisos para acceder a la aplicación")
            logging.warning("Intento de login usuario sin permisos: " + self.dlgLG.lineEdit_user.text() + " - " + self.dlgLG.lineEdit_pw.text())
        elif type == "server":
            if self.superLogin:
                self.attemptLogin(super = True)
            else:
                logging.warning("Error en servidor")
                QMessageBox.warning(self.dlgLG, "Error", "Servidor no disponible.")
        else:
            if self.superLogin:
                self.attemptLogin(super = True)
            else:
                logging.warning("LOGIN ERROR")
                QMessageBox.warning(self.dlgLG, "Login Error", "Error al intentar ingresar.")

    def failedDBLayers(self):
        self.iface.messageBar().pushMessage(
           "Layers SGC", "Error al cargar las layers de la base de datos.",level=Qgis.Warning, duration=3)

    # Load DB Layer at startup
    def loadDBLayers(self):
        # Delete previous layer files
        layer_path = os.path.join(self.current_dir,"temp","")
        files = glob.glob(f"{layer_path}*.qlr")
        for f in files:
            os.remove(f)
        # Remove layers from map
        if hasattr(self, 'dataLayers') and self.dataLayers is not None and "grupos" in self.dataLayers:
                # Just in case, remove temporarily added group
                self.loadTramiteLayerGroup(True)
                # Remove groups/layers from database
                for g in self.dataLayers["grupos"]:
                    root = QgsProject.instance().layerTreeRoot()
                    group = root.findGroup(g["nombre"])
                    if group is not None:
                        for child in group.children():
                            if isinstance(child,QgsLayerTreeGroup):
                                root.removeChildNode(child)
                            else:
                                QgsProject.instance().removeMapLayer(child.layerId())
                        root.removeChildNode(group)
                # Remove "Dibujos" group
                group = root.findGroup("Dibujos")
                if group is not None:
                    for child in group.children():
                        if isinstance(child,QgsLayerTreeGroup):
                            root.removeChildNode(child)
                        else:
                            QgsProject.instance().removeMapLayer(child.layerId())
                    root.removeChildNode(group)
        # Add parent root groups
        self.groups = [] # List of all groups 
        root_groups = list(filter(lambda l: l["padre"] is None,self.dataLayers["grupos"]))
        root_groups.sort(key=lambda l: l['id'],reverse=False)
        for r in root_groups:
            self.groups.append({"id": r["id"], "inicial": r["inicial"],"obj": QgsProject.instance().layerTreeRoot().addGroup(r["nombre"])})
            parent = self.groups[-1]
            # Add first level nested groups in order
            first_nest = list(filter(lambda l: l["padre"] == r["id"],self.dataLayers["grupos"]))
            first_nest.sort(key=lambda l: l['id'],reverse=False)
            for g in first_nest:
                self.groups.append({"id": g["id"],"inicial": g["inicial"], "obj": parent["obj"].addGroup(g["nombre"])})
        # Add rest of the groups
        remaining_groups = [r for r in self.dataLayers["grupos"] if r["id"] not in [g["id"] for g in self.groups]]
        added = 0
        while added < len(remaining_groups):
            for g in remaining_groups:
                if g["padre"] in [f["id"] for f in self.groups] and g["id"] not in [f["id"] for f in self.groups]:
                    temp_parent = list(filter(lambda l: l["id"] == g["padre"],self.groups))[0]
                    self.groups.append({"id": g["id"], "inicial": g["inicial"],"obj": temp_parent["obj"].addGroup(g["nombre"])})
                    added += 1
        # Add temp directory if it doesn't exist
        try: os.mkdir(os.path.join(self.current_dir,"temp"))
        except FileExistsError: pass
        # Layers add
        for l in self.dataLayers["layers"]:
            if l["estilo"] is not None:
                # Check if group exists and is "inicial"
                group = list(filter(lambda g: g["id"] == l["grupo"] and g["inicial"] is True,self.groups))
                if len(group) > 0:
                    group = group[0]["obj"]            
                    qgis_layers = QgsProject.instance().mapLayers().keys() # Save previous list of loaded layers
                    layer_path = os.path.join(self.current_dir,f"temp/{l['nombre']}.qlr")
                    f = open(layer_path, "x")
                    f.write(l["estilo"])
                    f.close()
                    layer_add_result = QgsLayerDefinition().loadLayerDefinition(layer_path,QgsProject.instance(),group)
                    os.remove(layer_path)
                    # If adding was succesful
                    if (layer_add_result[0]):
                        # save newly added layer by obtaining the current list of layers minus the previous list of layers
                        new_layer = QgsProject.instance().mapLayers()[list(set(QgsProject.instance().mapLayers()) - set(qgis_layers))[0]] 
                        if l["nombre_fisico"] is not None and l["nombre_fisico"].find("DIBUJO:") != -1:
                            new_layer.startEditing()
                        self.layers.append({"id": l["id"], 
                                            "tabla": l["tabla"],
                                            "tipo": "oms" if l["tipo"] == 0 else "", 
                                            "fisico": l["nombre_fisico"],
                                            "obj": new_layer,
                                            "default_visible": l["visible"]})
         
        # Project coordinate
        QgsProject.instance().setCrs(QgsCoordinateReferenceSystem(self.dataLayers["crs"]))
        # Do a zoom into Corrientes
        self.initialZoom()
        # Set layer visibility
        for l in self.dataLayers["layers"]:
            found_layer = [lay["obj"] for lay in self.layers if "id" in lay and lay["id"] == l["id"]]
            if len(found_layer)  > 0:
                layer = QgsProject.instance().layerTreeRoot().findLayer(found_layer[0])
                if layer is not None:
                    layer.setItemVisibilityChecked(l["visible"])
                    
        # Collapse layer groups
        nodes = QgsProject.instance().layerTreeRoot().children()

        for n in nodes:
            if isinstance(n, QgsLayerTreeGroup):
                if n.isExpanded() == True:
                    n.setExpanded(False)

    # Bandeja Tramites
    def featureAsociadaET(self,feature):
        
        item = self.dlgET.entradasTree.model().itemFromIndex(self.dlgET.entradasTree.selectionModel().selectedIndexes()[0]).data()
        
        # check if multiple parents
        id_objeto = item["id_objeto"]
        id_padres = [i["id_padre"] for i in self.dataET["entradas"] if i["id_objeto"] == id_objeto]
        featureLayer = [l["obj"] for l in self.layers if l["fisico"] == f"DIBUJO:{item['tabla']}"][0]
        # ========== Verificaciones =========
        layers = [l for l in self.layers if l["fisico"] is not None and l["fisico"].find("TEMPORAL:") != -1]
        errores_verificacion = []
        area_feature = feature.geometry().area()
        tolerancia_feature_hija = area_feature * float(self.dataET["parametros"]["TOLERANCIA_CONTENEDOR"]) / 100
        tolerancia_feature_area = (float(item['superficie']) * float(self.dataET["parametros"]["TOLERANCIA_SUPERFICIE"]) / 100) if item["superficie"] is not None else None
        tolerancia_feature_sup = area_feature * float(self.dataET["parametros"]["TOLERANCIA_SUPERPOSICION"]) / 100
        tiene_padre = False
        se_superpone = False

        # Objeto contenido padre  COMPUESTO
        # +
        # Que no exceda los limites de su contenedor hasta un determinado margen de tolerancia
        if len(id_padres) > 1:
            padre_geom = []
            tipo_layer_padre = [p["tipo"] for p in self.dataET["entradas"] if p["id"] == id_padres[0]][0]
            nombre_layer_padre = "TEMPORAL:PARCELAS" if tipo_layer_padre in ["PARCELA COMUN"] else "TEMPORAL:MANZANAS"
            layer_padre = [lay["obj"] for lay in self.layers if lay["fisico"] == nombre_layer_padre][0]
            for id in id_padres:
                feature_iterator = layer_padre.getFeatures( QgsFeatureRequest( QgsExpression( f"\"id\"={id}")))
                for f in feature_iterator:
                    padre_geom.append(f.geometry())
            fusion_geom = padre_geom[0]
            for p in padre_geom[1:]:
                fusion_geom = fusion_geom.combine(p)
            tiene_padre = True
            intersect_area = fusion_geom.intersection(feature.geometry()).area()
            if intersect_area < area_feature - tolerancia_feature_hija:
                errores_verificacion.append(f"El objeto geométrico seleccionado no se encuentra contenido en el objeto padre o se encuentra fuera de su contenedor en más de un {self.dataET['parametros']['TOLERANCIA_CONTENEDOR']}%")  
        for layer in layers:
            # Objeto contenido padre SIMPLE
            # +
            # Que no exceda los limites de su contenedor hasta un determinado margen de tolerancia
            for f in layer["obj"].getFeatures():
                if "id_padre" in item and f.attribute("id") == item["id_padre"] and len(id_padres) < 2:
                    tiene_padre = True
                    intersect_area = f.geometry().intersection(feature.geometry()).area()
                    if str(self.dataET["tramite"]["objeto"]) not in ['Adjudicación de partida inmobiliaria'] and intersect_area < area_feature - tolerancia_feature_hija:
                        errores_verificacion.append(f"El objeto geométrico seleccionado no se encuentra contenido en el objeto padre o se encuentra fuera de su contenedor en más de un {self.dataET['parametros']['TOLERANCIA_CONTENEDOR']}%")  
                # Que no se superpongan en un determinado margen (tolerancia) a otros objetos del mismo tipo
                if layer["fisico"].find(item["tipo"]) != -1 and  f.attribute("anidacion") == item["anidacion"] and not se_superpone:
                    intersect_area = f.geometry().intersection(feature.geometry()).area()
                    tolerancia_feature_sup_2 = f.geometry().area() * float(self.dataET["parametros"]["TOLERANCIA_SUPERPOSICION"]) / 100
                    if str(self.dataET["tramite"]["objeto"]) not in ['Adjudicación de partida inmobiliaria'] and intersect_area > tolerancia_feature_sup or intersect_area > tolerancia_feature_sup_2:
                        errores_verificacion.append(f"El objeto geométrico seleccionado se superpone a otro del mismo tipo y jerarquía en más de un {self.dataET['parametros']['TOLERANCIA_SUPERPOSICION']}%")  
                        se_superpone = True

        # Que tenga objeto grafico padre (necesario para calcular contenedor) salvo que sea prescripcion adquisitiva, reputacion y de division
        if str(self.dataET["tramite"]["objeto"]) not in ['Mensura Para Prescripción Adquisitiva', 'Mensura Para Prescripción Adquisitiva y División', 'Mensura para reputacion de dominio'] and item["anidacion"] > 0 and not tiene_padre:
            errores_verificacion.append("Se debe asociar el objeto gráfico padre primero")
        # Que no exceda de la superficie detallada en el registro
        if (item["superficie"] is not None) and ((area_feature < float(item["superficie"]) - tolerancia_feature_area) or (area_feature > float(item["superficie"]) + tolerancia_feature_area)):
            errores_verificacion.append(f"La diferencia entre la superficie del objeto seleccionado y la superficie registrada excede un {self.dataET['parametros']['TOLERANCIA_SUPERFICIE']}%. (Superficie del objeto seleccionado: {'%.2f' % area_feature}m². Registrado: {'%.2f' % float(item['superficie'])}m²)")
        
        if len(errores_verificacion) == 0:
            geometry = feature.geometry().asWkt()
            try:
                r = requests.put(url = self.URL + "geometria_temporal", data = json.dumps([{"id": item["id"],"featid": item["featid"],"tabla": item["tabla_grafica"],"geometry": geometry,"id_parcela": item["id_objeto"], "id_tramite": self.dataET["tramite"]["id_tramite"]}]), 
                                 headers={'Authorization': "Bearer {}".format(self.TOKEN)})
                if r.status_code == 200:
                    self.loadTramiteLayerGroup(True)
                    QMessageBox.information(self.dlgET, "Éxito", "Geometría asociada con éxito")
                    featureLayer.deleteFeatures([feature.id()])
                    featureLayer.triggerRepaint()
                    self.ETtabDatosEspecificos = True
                    self.procesarTramite()
                else:
                    logging.warning("Error en actualizacion geometrica de schema temporal")
                    QMessageBox.warning(self.dlgET, "Error", "Error en actualización de geometría")
            except requests.exceptions.ConnectionError:
                logging.warning("Error en servidor")
                QMessageBox.warning(self.dlgET, "Error", "Servidor no disponible")
            except (KeyboardInterrupt, SystemExit): raise
            except: 
                logging.warning("ERROR : " + str(sys.exc_info()[0]) + str(sys.exc_info()[1])  + str(sys.exc_info()[2]) + "Line: " + str(sys.exc_info()[2].tb_lineno))
                QMessageBox.warning(self.dlgET, "Error", "Error en servidor")
        else:
            errores_parrafo = ""
            for e in errores_verificacion:
                errores_parrafo += f"• {e}\n"
            QMessageBox.warning(self.dlgET, "Error en validación", errores_parrafo)

                
    def desasociarTramiteGeometry(self):
        item = self.dlgET.entradasTree.model().itemFromIndex(self.dlgET.entradasTree.selectionModel().selectedIndexes()[0]).data()
        nombre_capa_dibujo = "DIBUJO:VW_PARCELAS_GRAF_ALFA" if item["tipo"] == "PARCELA" else "DIBUJO:VW_MANZANAS"
        nombre_capa_feature = "TEMPORAL:PARCELAS" if item["tipo"] == "PARCELA" else "TEMPORAL:MANZANAS"
        dibujoFeatureLayer = [l["obj"] for l in self.layers if l["fisico"] == nombre_capa_dibujo][0]
        featureLayer = [l["obj"] for l in self.layers if l["fisico"] == nombre_capa_feature][0]
        feature = None
        for f in featureLayer.getFeatures():
            if f.attribute("id_objeto") == item["id_objeto"]:
                feature = f
        try:
            r = requests.delete(url = self.URL + "geometria_temporal", data = json.dumps([{"featid": item["featid"],"tabla": item["tabla_grafica"], "id_tramite": self.dataET["tramite"]["id_tramite"]}]), 
                             headers={'Authorization': "Bearer {}".format(self.TOKEN)})
            if r.status_code == 200:
                self.loadTramiteLayerGroup(True)
                QMessageBox.information(self.dlgET, "Éxito", "Geometría desasociada con éxito")
                if feature is not None:
                    message = QMessageBox(QMessageBox.Question,"Desasociar geometría", "¿Desea copiar la geometría a la capa de dibujo correspondiente?",
                        QMessageBox.Yes|QMessageBox.No, self.dlgET)
                    message.buttons()[0].setText("Si") 
                    reply = message.exec()
                    if reply == QMessageBox.Yes:
                        new_dibujo_feature = QgsFeature()
                        new_dibujo_feature.setGeometry(feature.geometry())
                        dibujoFeatureLayer.dataProvider().addFeatures([new_dibujo_feature])
                        dibujoFeatureLayer.triggerRepaint()

                self.ETtabDatosEspecificos = True
                self.procesarTramite()
            else:
                logging.warning("Error en desasociado geometrico de schema temporal")
                QMessageBox.warning(self.dlgET, "Error", "Error en desasociado de geometría")
        except requests.exceptions.ConnectionError:
            logging.warning("Error en servidor")
            QMessageBox.warning(self.dlgET, "Error", "Servidor no disponible")
        except (KeyboardInterrupt, SystemExit): raise
        except: 
            logging.warning("ERROR : " + str(sys.exc_info()[0]) + str(sys.exc_info()[1])  + str(sys.exc_info()[2]) + "Line: " + str(sys.exc_info()[2].tb_lineno))
            QMessageBox.warning(self.dlgET, "Error", "Error en servidor")

    def highlightTramiteFeature(self,item):
        [l["obj"] for l in self.layers if l["fisico"] == "TEMPORAL:PARCELAS"][0].removeSelection()
        [l["obj"] for l in self.layers if l["fisico"] == "TEMPORAL:MANZANAS"][0].removeSelection()
        nombre_capa_feature = "TEMPORAL:PARCELAS" if item["tipo"] == "PARCELA" else "TEMPORAL:MANZANAS"
        featureLayer = [l["obj"] for l in self.layers if l["fisico"] == nombre_capa_feature][0]
        feature = None
        for f in featureLayer.getFeatures():
            if f.attribute("id_objeto") == item["id_objeto"]:
                featureLayer.select(f.id())

    def loadTramiteLayerGroup(self, removal = False):
        if not removal:
            group = list(filter(lambda l: not l["inicial"],self.groups))
            group_id = group[0]["id"]
            group = group[0]["obj"]
            # Set Name
            self.tramiteGroupString = f"Tramite Nº: {self.dataET['tramite']['id_tramite']}"
            group.setName(self.tramiteGroupString)
            # Add layers
            for l in [l for l in self.dataLayers["layers"] if l["grupo"] == group_id]:
                qgis_layers = QgsProject.instance().mapLayers().keys() # Save previous list of loaded layers
                layer_path = os.path.join(self.current_dir,f"temp/{l['nombre']}.qlr")
                f = open(layer_path, "x")
                f.write(l["estilo"])
                f.close()
                QgsLayerDefinition().loadLayerDefinition(layer_path,QgsProject.instance(),group)
                os.remove(layer_path)
                # save newly added layer by obtaining the current list of layers minus the previous list of layers
                new_layer = QgsProject.instance().mapLayers()[list(set(QgsProject.instance().mapLayers()) - set(qgis_layers))[0]] 
                layer_provider = new_layer.dataProvider()
                layer_provider.addAttributes([QgsField("id",QVariant.Int)])
                layer_provider.addAttributes([QgsField("id_objeto",QVariant.Int)])
                layer_provider.addAttributes([QgsField("id_padre",QVariant.Int)])
                layer_provider.addAttributes([QgsField("anidacion",QVariant.Int)])
                new_layer.updateFields()
                self.layers.append({"id": l["id"], 
                                    "tabla": l["tabla"],
                                    "tipo": "oms" if l["tipo"] == 0 else "", 
                                    "fisico": l["nombre_fisico"],
                                    "obj": new_layer,
                                    "default_visible": l["visible"]})
        else:
            root = QgsProject.instance().layerTreeRoot()
            group = root.findGroup(self.tramiteGroupString)
            if group is not None:
                self.tramiteGroupString = "Tramite"
                group.setName(self.tramiteGroupString)
                for child in group.children():
                    if isinstance(child,QgsLayerTreeGroup):
                        root.removeChildNode(child)
                    else:
                        QgsProject.instance().removeMapLayer(child.layerId())
            # Remove temp layers of tramite
            layers_with_temp_removed = [l for l in self.layers if str(l["fisico"]).find("TEMPORAL:") == -1]
            self.layers = layers_with_temp_removed
            self.iface.mapCanvas().refresh()

    def adjuntoModalDescription(self):
        if self.first_start_DocInfo == True:
            self.first_start_DocInfo = False
            self.dlgDI = DocInfoDialog()
            # Lock resizing for user
            self.dlgDI.setMaximumSize(self.dlgDI.size())
            self.dlgDI.setMinimumSize(self.dlgDI.size())
            self.defaultSizeDI = self.dlgDI.size()
            self.dlgDI.setGeometry((QDesktopWidget().screenGeometry().width() / 2) - (self.defaultSizeDI.width() / 2),(QDesktopWidget().screenGeometry().height() / 2) - (self.defaultSizeDI.height() / 2),self.defaultSizeDI.width(),self.defaultSizeDI.height())

        self.dlgDI.textDescripcion.setPlainText(self.dlgET.tableAdjuntos.item(self.dlgET.tableAdjuntos.currentRow(),0).data(32)["descripcion"])
        self.dlgDI.textObservaciones.setPlainText(self.dlgET.tableAdjuntos.item(self.dlgET.tableAdjuntos.currentRow(),0).data(32)["observaciones"])
        self.dlgDI.setModal(True)
        self.dlgDI.show()

    def changeBandejaPage(self,page):
        if page == "reload":
            self.waitMsg = self.messageWait("Espere mientras se carga la bandeja de trámites...")
            thread = self.ServerLoaderBandejaTramites(self,self.bandejaPage)
            thread.finished.connect(self.finishedBandejaTramites)
            thread.failed.connect(self.failedBandejaTramites)
            thread.start()
        else:
            pagination = { 
                "next": self.bandejaPage + 1,
                "prev": self.bandejaPage - 1 if  self.bandejaPage - 1 >= 0 else 0,
            }
            self.bandejaPage = pagination[page]
            self.finishedBandejaTramites()

    def procesarTramite(self):
        if self.dlgBT.tableTramites.item(self.dlgBT.tableTramites.currentRow(),0) is not None:
            self.waitMsg = self.messageWait("Espere mientras se obtiene el trámite...")
            id_tramite = self.dlgBT.tableTramites.item(self.dlgBT.tableTramites.currentRow(),0).data(32)["id_tramite"]
            thread = self.ServerLoaderTramiteDatos(self,id_tramite)
            thread.finished.connect(self.finishedGetTramite)
            thread.failed.connect(self.failedGetTramite)
            thread.start() 

    def tramiteTreeButtons(self):
        self.dlgET.asociarButton.setVisible(self.dlgET.tramiteTabs.currentIndex() == 1)
        self.dlgET.desasociarButton.setVisible(self.dlgET.tramiteTabs.currentIndex() == 1)
        self.dlgET.asociarButton.setEnabled(False)
        self.dlgET.desasociarButton.setEnabled(False)

    def tramiteTreeSelectedItem(self):
        item = self.dlgET.entradasTree.model().itemFromIndex(self.dlgET.entradasTree.selectionModel().selectedIndexes()[0]).data()
        self.dlgET.asociarButton.setEnabled(not item["asociada"] and item.get("descripcion", "") != "SIN ORIGEN")
        self.dlgET.desasociarButton.setEnabled(item["asociada"])
        self.highlightTramiteFeature(item)

    def asociarTramiteGeometry(self):
        item = self.dlgET.entradasTree.model().itemFromIndex(self.dlgET.entradasTree.selectionModel().selectedIndexes()[0]).data()
        self.selectMapFeatureByClick(capa = f"DIBUJO:{item['tabla']}")       

    def finishedGetTramite(self): 
        self.waitMsg.done(0)
        self.toggleEnableToolbarIcons(False)
        self.whichDialog = "EditTramite"
        if self.first_start_EditTramite == True:
            self.first_start_EditTramite = False
            self.dlgET = EditTramiteDialog()
            # Lock resizing for user
            self.dlgET.setMaximumSize(self.dlgET.size())
            self.dlgET.setMinimumSize(self.dlgET.size())
            self.defaultSizeET = self.dlgET.size()
            self.dlgET.setGeometry((QDesktopWidget().screenGeometry().width() / 2) - (self.defaultSizeET.width() / 2),(QDesktopWidget().screenGeometry().height() / 2) - (self.defaultSizeET.height() / 2),self.defaultSizeET.width(),self.defaultSizeET.height())
            # Table config
            self.dlgET.tableAdjuntos.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
            self.dlgET.tableAdjuntos.horizontalHeader().setVisible(True) # only because QT Designer keeps setting this to False
            # Event handlers
            self.dlgET.closed.connect(lambda: self.toggleEnableToolbarIcons(False))
            self.dlgET.rejected.connect(lambda: self.toggleEnableToolbarIcons(False))
            self.dlgET.tableAdjuntos.itemDoubleClicked.connect(self.adjuntoModalDescription)
            self.dlgET.tramiteTabs.currentChanged.connect(self.tramiteTreeButtons)
            self.dlgET.desasociarButton.clicked.connect(self.desasociarTramiteGeometry)
            self.dlgET.asociarButton.clicked.connect(self.asociarTramiteGeometry)

        self.securityEditTramite()
        self.loadTramiteLayerGroup()
        # Tab
        self.dlgET.tramiteTabs.setCurrentIndex(1 if self.ETtabDatosEspecificos else 0)
        self.ETtabDatosEspecificos = False
        self.tramiteTreeButtons()
        # Data tab
        self.dlgET.lineId.setText(str(self.dataET["tramite"]["id_tramite"]))
        self.dlgET.lineNumeroTramite.setText(str(self.dataET["tramite"]["numero"]))
        self.dlgET.lineIniciador.setText(str(self.dataET["tramite"]["iniciador"]))
        self.dlgET.lineEstado.setText(str(self.dataET["tramite"]["estado"]))
        self.dlgET.lineTipo.setText(str(self.dataET["tramite"]["tipo"]))
        self.dlgET.lineJurisdiccion.setText(str(self.dataET["tramite"]["jurisdiccion"]))
        
        # Fix for fecha ingreso
        self.dataET["tramite"]["fecha_vto"] = re.search('([0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2})\\.?.*', self.dataET["tramite"]["fecha_vto"]) if self.dataET["tramite"]["fecha_vto"] is not None else None
        self.dataET["tramite"]["fecha_vto"] = self.dataET["tramite"]["fecha_vto"].group(1) if self.dataET["tramite"]["fecha_vto"] is not None else None
        self.dlgET.DateVencimiento.setDateTime(QDateTime.fromString(self.dataET["tramite"]["fecha_vto"] if self.dataET["tramite"]["fecha_vto"] is not None else "1900-01-01 00:00:00","yyyy-MM-dd HH:mm:ss"))
        
        # Fix for fecha libro diario weird format with microseconds and such        
        self.dataET["tramite"]["fecha_libro_diario"] = re.search('([0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2})\\.?.*', self.dataET["tramite"]["fecha_libro_diario"]) if self.dataET["tramite"]["fecha_libro_diario"] is not None else None
        self.dataET["tramite"]["fecha_libro_diario"] = self.dataET["tramite"]["fecha_libro_diario"].group(1) if self.dataET["tramite"]["fecha_libro_diario"] is not None else None
        self.dlgET.DateLibroDiario.setDateTime(QDateTime.fromString(self.dataET["tramite"]["fecha_libro_diario"] if self.dataET["tramite"]["fecha_libro_diario"] is not None else "1900-01-01 00:00:00","yyyy-MM-dd HH:mm:ss"))
        
        # Fix for fecha ingreso
        self.dataET["tramite"]["fecha_ingreso"] = re.search('([0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2})\\.?.*', self.dataET["tramite"]["fecha_ingreso"]) if self.dataET["tramite"]["fecha_ingreso"] is not None else None
        self.dataET["tramite"]["fecha_ingreso"] = self.dataET["tramite"]["fecha_ingreso"].group(1) if self.dataET["tramite"]["fecha_ingreso"] is not None else None
        self.dlgET.DateIngreso.setDateTime(QDateTime.fromString(self.dataET["tramite"]["fecha_ingreso"],"yyyy-MM-dd HH:mm:ss")) if self.dataET["tramite"]["fecha_ingreso"] is not None else self.dlgET.DateIngreso.clear()
        
        # Rest of stuff
        self.dlgET.linePrioridad.setText(str(self.dataET["tramite"]["prioridad"]))
        self.dlgET.lineObjeto.setText(str(self.dataET["tramite"]["objeto"]))
        self.dlgET.lineLocalidad.setText(str(self.dataET["tramite"]["localidad"]))
        self.dlgET.textMotivo.setText(str(self.dataET["tramite"]["motivo"]))
        # Adjunto Tab
        self.dlgET.tableAdjuntos.clearSelection()
        self.dlgET.tableAdjuntos.setRowCount(0)
        for t in self.dataET["adjuntos"]:
            self.dlgET.tableAdjuntos.insertRow(self.dlgET.tableAdjuntos.rowCount())
            items = []
            items.append(QTableWidgetItem(t["fecha"][:10] if t["fecha"] is not None else ""))
            items.append(QTableWidgetItem(t["persona"]))
            items.append(QTableWidgetItem(t["tipo"]))
            items.append(QTableWidgetItem(t["adjunto"]))
            for i in range(4):
                font = items[i].font()
                font.setPointSize(13)
                items[i].setFont(font)
                items[i].setFlags(Qt.ItemIsEnabled|Qt.ItemIsSelectable)
                items[i].setData(32,{"id_documento": t["id_documento"], "observaciones": t["observaciones"], "descripcion": t["descripcion"]})
                self.dlgET.tableAdjuntos.setItem(self.dlgET.tableAdjuntos.rowCount() - 1,i,items[i])
        # Tab with tree of entradas. Entradas tree.
        # Model and config
        model = QStandardItemModel()
        # Fix for parcelas
        for e in self.dataET["entradas"]:
            if e['tabla'] == 'VW_PARCELAS':
                e['tabla'] = 'VW_PARCELAS_GRAF_ALFA'
        # Parents
        parents_data = [e for e in self.dataET["entradas"] if e["id_padre"] is None]
        parents = []
        for p in parents_data:
            if p['descripcion'] == "PARCELA":
                descripcion = f"{p['descripcion']} {p['origen_o_destino']}: Partida Inmobiliaria: {p['partida_inmobiliaria']} Nomenclatura Catastral: {p['nomenclatura'] if p['nomenclatura'] else ''}"
            if p['descripcion'] == "MANZANA":
                descripcion = f"{p['descripcion']}: ID s/Plano: {p['id_plano']}"
            if p['descripcion'] == "VIA":
                descripcion = f"{p['descripcion']}: ID s/Plano: {p['id_plano']} – Tipo: {p['tipo']}"
            if "asociada" in p and p["asociada"]:
                parents.append(QStandardItem(QIcon(os.path.join(self.current_dir,'icons/ok.png')), descripcion))
            else:
                parents.append(QStandardItem(QIcon(os.path.join(self.current_dir,'icons/cancel.png')), descripcion))
            parents[-1].setData({"id": p["id"],
                                 "asociada": p["asociada"] if "asociada" in p else False,
                                 "tipo": p["descripcion"], 
                                 "tabla_grafica": p["tabla_grafica"], 
                                 "featid": p["featid"],
                                 "tabla": p["tabla"],
                                 "superficie": p["superficie"] if "superficie" in p else None,
                                 "anidacion": 0,
                                 "id_objeto": p["id_objeto"] if "id_objeto" in p else None})
            p["anidacion"] = 0
            font = parents[-1].font()
            font.setPointSize(13)
            parents[-1].setFont(font)
            model.appendRow(parents[-1])

        children_data = [copy.copy(e) for e in self.dataET["entradas"] if e["id_padre"] is not None]
        children = []
        runs = 0
        while len(children_data) > 0:
            for c in children_data:
                # if c["tabla_grafica"] == None: #borrar
                #     c["tabla_grafica"] = "oa_division"
                parent = None
                if c["id_padre"] in [p.data()["id"] for p in parents]:
                    parent = [p for p in parents if p.data()["id"] == c["id_padre"]][0]
                elif c["id_padre"] in [p.data()["id"] for p in children]:
                    parent = [p for p in children if p.data()["id"] == c["id_padre"]][0]
                elif str(self.dataET["tramite"]["objeto"]) in ['Mensura Para Prescripción Adquisitiva', 'Mensura Para Prescripción Adquisitiva y División', 'Mensura para reputacion de dominio']:
                    parents.append(QStandardItem(QIcon(os.path.join(self.current_dir,'icons/cancel.png')), 'PARCELAS SIN ORIGEN'))
                    parents[-1].setData({"id": c["id_padre"],
                                 "asociada": False,
                                 "tipo": c["descripcion"], 
                                 "descripcion" : "SIN ORIGEN",
                                 "tabla_grafica": c["tabla_grafica"], 
                                 "featid": c["featid"],
                                 "tabla": c["tabla"],
                                 "superficie": c["superficie"] if "superficie" in c else None,
                                 "anidacion": 0,
                                 "id_objeto": c["id_objeto"] if "id_objeto" in c else None})
                    font = parents[-1].font()
                    font.setPointSize(13)
                    parents[-1].setFont(font)
                    model.appendRow(parents[-1])
                    parent = parents[-1]
                if parent:
                    if c['descripcion'] == "PARCELA":
                        descripcion = f"{c['descripcion']} {c['origen_o_destino']}: ID s/Plano: {c['id_plano']} – Tipo: {c['tipo'] if 'tipo' in c else ''}"
                    if c['descripcion'] == "MANZANA":
                        descripcion = f"{c['descripcion']}: ID s/Plano: {c['id_plano'] if 'id_plano' in c else ''}"
                    if c['descripcion'] == "VIA":
                        descripcion = f"{c['descripcion']}: ID s/Plano: {c['id_plano']} – Tipo: {c['tipo']}"
                    if "asociada" in c and c["asociada"]:
                        child = QStandardItem(QIcon(os.path.join(self.current_dir,'icons/ok.png')), descripcion)
                    else:
                        child = QStandardItem(QIcon(os.path.join(self.current_dir,'icons/cancel.png')),descripcion)
                    child.setData({"id": c["id"],
                                   "id_padre":c["id_padre"], 
                                   "asociada": c["asociada"] if "asociada" in c else False,
                                   "tipo": c["descripcion"], 
                                   "tabla_grafica": c["tabla_grafica"], 
                                   "tabla": c["tabla"],
                                   "featid": c["featid"],
                                   "superficie": c["superficie"] if "superficie" in c else None,
                                   "anidacion": parent.data()["anidacion"] + 1,
                                   "id_objeto": c["id_objeto"] if "id_objeto" in c else None})
                    for e in self.dataET["entradas"]:
                        if e["id"] == c["id"]:
                            e["anidacion"] = parent.data()["anidacion"] + 1
                    font = child.font()
                    font.setPointSize(13)
                    child.setFont(font)
                    parent.appendRow(child)
                    children.append(child)
                    children_data.pop(children_data.index(c))
                    break
        print('Configurando el modelo del QTreeView...')
        print('Número de padres:', len(parents))
        print('Número de hijos:', len(children))         
        # Tree view configs
        self.dlgET.entradasTree.setModel(model)
        self.dlgET.entradasTree.setUniformRowHeights(True)
        self.dlgET.entradasTree.setHeaderHidden(True)
        self.dlgET.entradasTree.expandAll() 
        self.dlgET.entradasTree.horizontalScrollBar().setEnabled(True)
        self.dlgET.entradasTree.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.dlgET.entradasTree.header().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.dlgET.entradasTree.header().setStretchLastSection(False)
        self.dlgET.entradasTree.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)
        self.dlgET.entradasTree.setEditTriggers(QAbstractItemView.NoEditTriggers)


        # Load geometries
        for e in self.dataET['entradas']:
            if "geometry" in e and e["geometry"] is not None:
                g = QgsGeometry.fromWkt(e["geometry"])
                feature = QgsFeature()
                fields = QgsFields()
                id_field = QgsField("id",QVariant.Int)
                id_objeto_field = QgsField("id_objeto",QVariant.Int)
                id_padre_field = QgsField("id_padre",QVariant.Int)
                anidacion_field = QgsField("anidacion",QVariant.Int)
                fields.append(id_field)
                fields.append(id_objeto_field)
                fields.append(id_padre_field)
                fields.append(anidacion_field)
                feature.setFields(fields)
                feature.setAttribute("id",e["id"])
                feature.setAttribute("id_objeto",e["id_objeto"])
                feature.setAttribute("id_padre",e["id_padre"])
                feature.setAttribute("anidacion",e["anidacion"])
                feature.setGeometry(g)
                if e["descripcion"] == "PARCELA":
                    layer = [lay["obj"] for lay in self.layers if lay["fisico"] == "TEMPORAL:PARCELAS"][0]
                    layer.dataProvider().addFeatures([feature])
                    layer.commitChanges()
                elif e["descripcion"] == "MANZANA":
                    layer = [lay["obj"] for lay in self.layers if lay["fisico"] == "TEMPORAL:MANZANAS"][0]
                    layer.dataProvider().addFeatures([feature])
                    layer.commitChanges()
        # Zoom in 
        zoomed_in = False
        layer = [lay["obj"] for lay in self.layers if lay["fisico"] == "TEMPORAL:PARCELAS"][0]
        features = [f for f in layer.getFeatures()]
        if len(features) > 0:
            for f in features:
                layer.select(f.id())
                box = layer.boundingBoxOfSelected()
                self.iface.mapCanvas().setExtent(box)
                self.iface.mapCanvas().refresh()
                zoomed_in = True
                break
        if not zoomed_in:
            layer = [lay["obj"] for lay in self.layers if lay["fisico"] == "TEMPORAL:MANZANAS"][0]
            features = [f for f in layer.getFeatures()]
            for f in features:
                layer.select(f.id())
                box = layer.boundingBoxOfSelected()
                self.iface.mapCanvas().setExtent(box)
                self.iface.mapCanvas().refresh()
                zoomed_in = True
                break

        # Connect tree events
        try: self.dlgET.entradasTree.selectionModel().selectionChanged.disconnect()
        except (KeyboardInterrupt, SystemExit): raise
        except: pass
        self.dlgET.entradasTree.selectionModel().selectionChanged.connect(self.tramiteTreeSelectedItem)

       # Deselect all features from all layers
        for l in [l["obj"] for l in self.layers if l["tipo"] != "oms"]:
            l.removeSelection()
        # Dialog Show
        print('Asignando datos a los ítems del QTreeView...')
        print('Número de padres creados:', len(parents))
        print('Número de hijos creados:', len(children))
        self.minimizeDialog("dlgBT")
        self.dlgET.show()

    def failedGetTramite(self, type):
        self.waitMsg.done(0)
        if type == "server":
            logging.warning("Error en servidor")
            QMessageBox.warning(self.dlgBT, "Error", "Servidor no disponible.")
        else:
            logging.warning("Error en obtención de trámite")
            QMessageBox.warning(self.dlgBT, "Error", "Error al obtener trámite.")
    """
        -----------------
    """
    # Change Password
    def finishedChangePass(self): 
        self.waitMsg.done(0)
        if self.passChange:
            self.passChange = False
            QMessageBox.information(self.iface.mainWindow(), "¡Éxito!", "Cambio de contraseña exitoso. Favor de volver a ingresar con su contraseña nueva.")
        else:
            self.iface.messageBar().pushMessage(
                "¡Éxito!", "Cambio de contraseña exitoso",level=Qgis.Success, duration=3)

    def failedChangePass(self, type):
        self.waitMsg.done(0)
        if type == "server":
            logging.warning("Error en servidor")
            QMessageBox.warning(self.iface.mainWindow(), "Error", "Servidor no disponible.")
        else:
            logging.warning("Error en cambio de contraseña")
            QMessageBox.warning(self.iface.mainWindow(), "Error", "Error al intentar actualizar la contraseña.")

    def finishedBandejaTramites(self):
        self.waitMsg.done(0)
        self.dlgBT.lineUsuario.setText(f"{self.user_data['Nombre']} {self.user_data['Apellido']}")
        self.dlgBT.lineSector.setText(self.dataBT['sector'])
        self.dlgBT.tableTramites.clearSelection()
        self.dlgBT.tableTramites.setRowCount(0)
        desde = self.bandejaPage * 10 + 1
        hasta = self.bandejaPage * 10 + 10
        total = self.dataBT['cant']
        self.dlgBT.labelMostrando.setText(f"Mostrando del {desde} al {hasta if hasta <= total else total} de un total de {total}")
        self.dlgBT.prevButton.setEnabled(self.bandejaPage > 0)
        self.dlgBT.nextButton.setEnabled(self.bandejaPage * 10 + 10 < self.dataBT['cant'])

        for t in self.dataBT["tramites"][desde - 1 : hasta]:
            self.dlgBT.tableTramites.insertRow(self.dlgBT.tableTramites.rowCount())
            items = []
            items.append(QTableWidgetItem(str(t["id_tramite"])))
            items.append(QTableWidgetItem(t["numero"]))
            items.append(QTableWidgetItem(t["tipo"]))
            items.append(QTableWidgetItem(t["objeto"]))
            items.append(QTableWidgetItem(t["prioridad"]))
            items.append(QTableWidgetItem(t["fecha_venc"][:10] if t["fecha_venc"] is not None else ""))
            for i in range(6):
                font = items[i].font()
                font.setPointSize(13)
                items[i].setFont(font)
                items[i].setFlags(Qt.ItemIsEnabled|Qt.ItemIsSelectable)
                items[i].setData(32,{"id_tramite": t["id_tramite"]})
                self.dlgBT.tableTramites.setItem(self.dlgBT.tableTramites.rowCount() - 1,i,items[i])
        self.dlgBT.show()

    def failedBandejaTramites(self,type):
        if type == "db":
            QMessageBox.warning(self.iface.mainWindow(), "Error", "Error en base de datos")
        elif type == "server":
            logging.warning("Error en servidor")
            QMessageBox.warning(self.iface.mainWindow(), "Error", "Servidor no disponible.")

    def performConsulta(self):
        self.dlgC.resultsTable.clearSelection()
        self.dlgC.resultsTable.setRowCount(0)
        self.dlgC.labelNoEncontrado.setVisible(False)
        self.dlgC.labelResultados.setVisible(False)
        # if self.dlgC.lineSearch.text() != "":
        try:
            r = requests.get(url = self.URL + "search", data = json.dumps({"search_terms": self.dlgC.lineSearch.text(),"tipo": self.dlgC.comboObjeto.currentText().lower()}),
                             headers={'Authorization': "Bearer {}".format(self.TOKEN)})
            if r and r.status_code == 200:
                logging.info("Succesful search request")
                total_docs = int(r.json()["response"]["numFound"])
                docs = r.json()["response"]["docs"]
                rows = int(r.json()["responseHeader"]["params"]["rows"])
                #docs.sort(key=lambda f: f['nombre'],reverse=False)
                if len(docs) > 0:
                    self.dlgC.setMaximumSize(self.defaultSizeC)
                    self.dlgC.setMinimumSize(self.defaultSizeC)
                    self.dlgC.resize(self.defaultSizeC)

                    for d in docs:
                        d['dato_tienegeom'] = d['dato_tienegeom'] == "TRUE"
                        d['descripcion'] = re.sub(r'<br>', "\n", d['descripcion'])
                        self.dlgC.resultsTable.insertRow(self.dlgC.resultsTable.rowCount())
                        items = []
                        items.append(QTableWidgetItem(QIcon(os.path.join(self.current_dir,'icons/ok.png')) if d['dato_tienegeom'] else QIcon(os.path.join(self.current_dir,'icons/cancel.png')),""))
                        items.append(QTableWidgetItem(f"{d['nombre'] if 'nombre' in d else ''}{'-' if 'nombre' in d and 'dato_nomenclatura' in d else ''}{d['dato_nomenclatura'] if 'dato_nomenclatura' in d else ''}"))
                        items.append(QTableWidgetItem(d['descripcion']))
                        for i in range(3):
                            font = items[i].font()
                            font.setPointSize(10)
                            items[i].setFont(font)
                            items[i].setFlags(Qt.ItemIsEnabled|Qt.ItemIsSelectable)
                            items[i].setData(32,d)
                            self.dlgC.resultsTable.setItem(self.dlgC.resultsTable.rowCount() - 1,i,items[i])
                    if len(docs) == 1:
                        self.consultaItemClicked(items[0], no_error_message = True)
                    if total_docs > rows:
                        self.dlgC.labelResultados.setVisible(True)
                        self.dlgC.labelResultados.setText(f"Mostrando {len(docs)} de {total_docs} resultados.\nPara mejor precisión, ajuste el filtro ingresado.")
                else:
                    self.dlgC.setMaximumSize(self.smallerSizeC)
                    self.dlgC.setMinimumSize(self.smallerSizeC)
                    self.dlgC.resize(self.smallerSizeC)
                    self.dlgC.labelNoEncontrado.setVisible(True)
                    self.dlgC.labelResultados.setVisible(False)
            else:
                logging.warning("Error en busqueda: " + str(sys.exc_info()[0]) + str(sys.exc_info()[1]) + " Line: " + str(sys.exc_info()[2].tb_lineno))
                QMessageBox.warning(self.dlgC, "Error", "Error en Busqueda")
        except requests.exceptions.ConnectionError:
            logging.info("Error en servidor")
            QMessageBox.warning(self.dlgC, "Error", "Servidor no disponible")
        except (KeyboardInterrupt, SystemExit): raise
        except:
            logging.warning("Error en busqueda: " + str(sys.exc_info()[0]) + str(sys.exc_info()[1]))
            QMessageBox.warning(self.dlgC, "Error", "Error en busqueda")

    def consultaItemClicked(self,item, no_error_message = False):
        try:
            dialog = self.dlgEOG if self.whichDialog == "EditObjetoGrafico" else (self.dlgC if self.whichDialog == "Consulta" else self.iface.mainWindow())
            r = requests.get(url = self.URL + "objeto_geometry", data = json.dumps(item.data(32)),
                             headers={'Authorization': "Bearer {}".format(self.TOKEN)})
            if r and r.status_code == 200 and r.json()["x"] is not None and r.json()["y"] is not None:
                logging.info("Succesful Geometry Query")
                # Deselect all features from all layers
                for l in [l["obj"] for l in self.layers if l["tipo"] != "oms"]:
                    l.removeSelection()
                layerData = [l for l in self.layers if  "tabla" in l and l["tabla"] == item.data(32)["capa"]][0]
                layer = layerData["obj"]
                layerTreeObj  = QgsProject.instance().layerTreeRoot().findLayer(layer)
                layerTreeObj.setItemVisibilityChecked(True)
                geometry = r.json()
                canvas = self.iface.mapCanvas()
                scale = 32500
                mapPoint = QgsPointXY(geometry["x"], geometry["y"])

                if "envelope" in geometry:
                    envelope = geometry["envelope"]
                    env_points = re.split(",| ",re.search('(?<=^POLYGON\\(\\().+(?=\\)\\))', envelope).group(0))
                    x_extent = abs(float(env_points[0]) - float(env_points[4]))
                    y_extent = abs(float(env_points[1]) - float(env_points[5]))
                    rect = QgsRectangle(mapPoint.x() - x_extent * 1.3, mapPoint.y() - y_extent * 1.3, mapPoint.x() + x_extent  * 1.3, mapPoint.y() + y_extent * 1.3)
                else:
                    rect = QgsRectangle(mapPoint.x() - scale, mapPoint.y() - scale, mapPoint.x() + scale, mapPoint.y() + scale)

                def select():
                    canvas.mapCanvasRefreshed.disconnect(select)
                    screenPoint = QgsMapTool(canvas).toCanvasCoordinates(mapPoint)
                    feature_selection = QgsMapToolIdentify(canvas).identify(screenPoint.x(),screenPoint.y(),[layer],QgsMapToolIdentify.DefaultQgsSetting) if item.data(32)["capa"] != "VW_LOCALIDAD_GRAFICA" else []
                    if len(feature_selection) > 0:
                        layer.select(feature_selection[0].mFeature.id())

                canvas.mapCanvasRefreshed.connect(select)
                canvas.setExtent(rect)
                canvas.refresh()
            else:
                logging.warning("Error en query geometria: " + r.text)
                if not no_error_message:
                    QMessageBox.warning(dialog, "Error", "El objeto seleccionado no posee geometría")
        except requests.exceptions.ConnectionError:
            logging.info("Error en servidor")
            QMessageBox.warning(dialog, "Error", "Servidor no disponible")
        except (KeyboardInterrupt, SystemExit): raise
        except:
            logging.warning("Error en query geometria: " + str(sys.exc_info()[0]) + str(sys.exc_info()[1]) + "Line: " + str(sys.exc_info()[2].tb_lineno))
            QMessageBox.warning(dialog, "Error", "El objeto seleccionado no posee geometría")


    def consultaComboChanged(self):
        self.dlgC.setMaximumSize(self.smallerSizeC)
        self.dlgC.setMinimumSize(self.smallerSizeC)
        self.dlgC.resize(self.smallerSizeC)

    # ABM objetos graficos
    def finishedUpdateGeometryEOG(self, feature):
        self.waitMsg.done(0)
        asociar = self.dataEOG["asociar"]
        item = self.dlgEOG.resultsTable.currentItem().data(32)
        self.buscarObjetoABM()
        QMessageBox.information(self.dlgEOG, "Éxito", f"Geometría {'asociada' if asociar else 'desasociada'} con éxito.\n\nEl buscador puede demorar unos minutos en actualizarse.")
        if asociar: # Borrar objeto de capa de dibujo
            capa = item['capa']
            if capa in ["VW_PARCELAS_GRAF_ALFA_RURALES", "VW_PARCELAS_PRESCRIPCIONES", "VW_PARCELAS_PH"]: # Fix for VW_PARCELAS_GRAF_ALFA_RURALES PRESCRIPCIONES PH
                capa = "VW_PARCELAS_GRAF_ALFA"
            featureLayer = [l["obj"] for l in self.layers if l["fisico"] == f"DIBUJO:{capa}"][0]
            featureLayer.deleteFeatures([feature.id()])
            featureLayer.triggerRepaint()
        else:
            message = QMessageBox(QMessageBox.Question,"Geometría desasociada", "¿Desea copiar la geometría desasociada a la capa de dibujo correspondiente?",
                QMessageBox.Yes|QMessageBox.No, self.dlgEOG)
            message.buttons()[0].setText("Si") 
            reply = message.exec()
            if reply == QMessageBox.Yes:
                capa = item['capa']
                if capa in ["VW_PARCELAS_GRAF_ALFA_RURALES", "VW_PARCELAS_PRESCRIPCIONES", "VW_PARCELAS_PH"]: # Fix for VW_PARCELAS_GRAF_ALFA_RURALES  PRESCRIPCIONES PH
                    capa = "VW_PARCELAS_GRAF_ALFA"
                featureLayer = [l["obj"] for l in self.layers if l["fisico"] == f"DIBUJO:{capa}"][0]
                new_dibujo_feature = QgsFeature()
                new_dibujo_geo = QgsGeometry().fromWkt(self.dataEOG["geometry"])
                new_dibujo_feature.setGeometry(new_dibujo_geo)
                featureLayer.dataProvider().addFeatures([new_dibujo_feature])
                featureLayer.triggerRepaint()

        # Ŕefrescar capa WFS (pasa en asociar y desasociar)
        capa = item['capa']
        if capa in ["VW_PARCELAS_PH"]: #Fix for PH
            wfsLayer = [l["obj"] for l in self.layers if l["fisico"] == capa][0]
            wfsLayer.dataProvider().reloadData()
            wfsLayer.triggerRepaint()

    def failedUpdateGeometryEOT(self,message):
        self.waitMsg.done(0)
        
        if message == "db":
            asociar = self.dataEOG["asociar"]
            error_response = self.dataEOG["ERROR"]
            logging.warning(f"Error en {'asociado' if asociar else 'desasociado'} geometrico de objeto sin tramite: {error_response}")
            if type(error_response) is list:
                errores_parrafo = ""
                for e in error_response:
                    errores_parrafo += f"• {e}\n"
                QMessageBox.warning(self.dlgEOG, "Error en validación", errores_parrafo)
            else:
                QMessageBox.warning(self.dlgEOG, "Error", f"Error en {'asociado' if asociar else 'desasociado'} de geometría")

        if message == "server":
            QMessageBox.warning(self.dlgEOG, "Error", "Servidor no disponible")
        if message == "other_error":
            QMessageBox.warning(self.dlgEOG, "Error", "Error en servidor")



    def EOGdesasociarGeometria(self):
        self.EOGupdateGeometria(asociar = False)

    def EOGasociarGeometria(self):
        item = self.dlgEOG.resultsTable.currentItem().data(32)
        capa = item['capa']
        if capa in ["VW_PARCELAS_GRAF_ALFA_RURALES", "VW_PARCELAS_PRESCRIPCIONES", "VW_PARCELAS_PH"]: # Fix for VW_PARCELAS_GRAF_ALFA_RURALES y PRESCRIPCIONES
            capa = "VW_PARCELAS_GRAF_ALFA"
        self.selectMapFeatureByClick(capa = f"DIBUJO:{capa}")

    def EOGupdateGeometria(self, asociar = True, feature = None):
        item = self.dlgEOG.resultsTable.currentItem().data(32)
        message = QMessageBox(QMessageBox.Question, f"{'Asociación' if asociar else 'Desasociación'} de geometría", 
            f"¿Está seguro de que desea {'asociar la geometría elegida al' if asociar else 'desasociar la geometría del'} objeto seleccionado?"
            f"\nObjeto seleccionado: \nTipo: {item['tipo']}\nNombre: {item['nombre']}\nDescripción: {item['descripcion']}",
            QMessageBox.Yes|QMessageBox.No, self.dlgEOG)
        message.buttons()[0].setText("Si") 
        reply = message.exec()
        if reply == QMessageBox.Yes:
            item["geometry"] = feature.geometry().asWkt() if asociar else "NULL"
            item["dato_tienegeom"] = "TRUE" if asociar else "FALSE"
            item["hostname"] = platform.uname()[1]
            self.waitMsg = self.messageWait("Espere mientras se procesa el cambio...")
            thread = self.ServerLoaderUpdateGeometryEOG(self, item, asociar)
            thread.finished.connect(lambda: self.finishedUpdateGeometryEOG(feature))
            thread.failed.connect(self.failedUpdateGeometryEOT)
            thread.start() 

    def buttonsToggleABM(self,asociar = False, desasociar = False):
        self.dlgEOG.buttonAsociar.setEnabled(asociar)
        self.dlgEOG.buttonDesasociar.setEnabled(desasociar)
    
    def EOGresultsTableItemSelected(self):
        has_geometry = self.dlgEOG.resultsTable.currentItem().data(32)["dato_tienegeom"]
        self.buttonsToggleABM(not has_geometry, has_geometry)

    def buscarObjetoABM(self):
        mostrados = 0
        self.dlgEOG.resultsTable.clearSelection()
        self.dlgEOG.resultsTable.setRowCount(0)
        self.dlgEOG.labelNoEncontrado.setVisible(False)
        self.dlgEOG.labelResultados.setVisible(False)
        self.buttonsToggleABM()
        try:
            r = requests.get(url = self.URL + "search_ABM", data = json.dumps({"search_terms": self.dlgEOG.lineBuscar.text(),"tipo": self.dlgEOG.comboObjeto.currentText().lower()}),
                             headers={'Authorization': "Bearer {}".format(self.TOKEN)})
            if r and r.status_code == 200:
                logging.info("Succesful search request")
                total_docs = int(r.json()["response"]["numFound"])
                docs = r.json()["response"]["docs"]
                rows = int(r.json()["responseHeader"]["params"]["rows"])
                #docs.sort(key=lambda f: f['nombre'],reverse=False)
                if len(docs) > 0:
                    for d in docs:
                        items = []
                        if self.dlgEOG.comboObjeto.currentText().lower() != 'parcelas' and self.dlgEOG.comboObjeto.currentText().lower() != 'prescripciones':
                            d['dato_tienegeom'] = d['dato_tienegeom'] == "TRUE"
                            d['descripcion'] = re.sub(r'<br>', "\n", d['descripcion'])
                            self.dlgEOG.resultsTable.insertRow(self.dlgEOG.resultsTable.rowCount())
                            items.append(QTableWidgetItem(QIcon(os.path.join(self.current_dir,'icons/ok.png')) if d['dato_tienegeom'] else QIcon(os.path.join(self.current_dir,'icons/cancel.png')),""))
                            items.append(QTableWidgetItem(f"{d['nombre'] if 'nombre' in d else ''}{'-' if 'nombre' in d and 'dato_nomenclatura' in d else ''}{d['dato_nomenclatura'] if 'dato_nomenclatura' in d else ''}"))
                            items.append(QTableWidgetItem(d['descripcion']))
                            mostrados+=1
                            for i in range(3):
                                font = items[i].font()
                                font.setPointSize(10)
                                items[i].setFont(font)
                                items[i].setFlags(Qt.ItemIsEnabled|Qt.ItemIsSelectable)
                                #items[i].setData(32,{"id": d["id"], "tipo": d["tipo"], "tabla": d["capa"], "nombre": d["nombre"],"tabla_padre": d['dato_tablapadre'],"id_padre": d['idpadre'] if 'idpadre' in d else None,"geometry": d['dato_tienegeom']})
                                items[i].setData(32,d)
                                self.dlgEOG.resultsTable.setItem(self.dlgEOG.resultsTable.rowCount() - 1,i,items[i])
                        else:
                            if str(d['descripcion'])[str(d['descripcion']).find('Superficie')+12: str(d['descripcion']).find('Superficie')+15] > '0 m2':
                                d['dato_tienegeom'] = d['dato_tienegeom'] == "TRUE"
                                d['descripcion'] = re.sub(r'<br>', "\n", d['descripcion'])
                                self.dlgEOG.resultsTable.insertRow(self.dlgEOG.resultsTable.rowCount())
                                items.append(QTableWidgetItem(QIcon(os.path.join(self.current_dir,'icons/ok.png')) if d['dato_tienegeom'] else QIcon(os.path.join(self.current_dir,'icons/cancel.png')),""))
                                items.append(QTableWidgetItem(f"{d['nombre'] if 'nombre' in d else ''}{'-' if 'nombre' in d and 'dato_nomenclatura' in d else ''}{d['dato_nomenclatura'] if 'dato_nomenclatura' in d else ''}"))
                                items.append(QTableWidgetItem(d['descripcion']))
                                mostrados+=1
                                for i in range(3):
                                    font = items[i].font()
                                    font.setPointSize(10)
                                    items[i].setFont(font)
                                    items[i].setFlags(Qt.ItemIsEnabled|Qt.ItemIsSelectable)
                                    #items[i].setData(32,{"id": d["id"], "tipo": d["tipo"], "tabla": d["capa"], "nombre": d["nombre"],"tabla_padre": d['dato_tablapadre'],"id_padre": d['idpadre'] if 'idpadre' in d else None,"geometry": d['dato_tienegeom']})
                                    items[i].setData(32,d)
                                    self.dlgEOG.resultsTable.setItem(self.dlgEOG.resultsTable.rowCount() - 1,i,items[i])
                    if total_docs > rows:
                        self.dlgEOG.labelResultados.setVisible(True)
                        self.dlgEOG.labelResultados.setText(f"Mostrando {mostrados} de {total_docs-(len(docs)-mostrados)} resultados. Para una mejor precisión , ajuste el filtro ingresado.")
                    if len(docs) == 1 and self.dlgEOG.comboObjeto.currentText().lower() != 'parcelas':
                        self.consultaItemClicked(items[0], no_error_message = True)
                    if len(docs) == 1 and self.dlgEOG.comboObjeto.currentText().lower() == 'parcelas':
                        if str(d['descripcion'])[str(d['descripcion']).find('Superficie')+12: str(d['descripcion']).find('Superficie')+15] in ['0 m2', '0 ha']:
                            self.dlgEOG.labelNoEncontrado.setVisible(True)
                            self.dlgEOG.labelResultados.setVisible(False)
                        else:
                            self.consultaItemClicked(items[0], no_error_message = True)
                else:
                    self.dlgEOG.labelNoEncontrado.setVisible(True)
                    self.dlgEOG.labelResultados.setVisible(False)
            else:
                logging.warning("Error en busqueda: " + str(sys.exc_info()[0]) + str(sys.exc_info()[1]))
                QMessageBox.warning(self.dlgEOG, "Error", "Error en Busqueda")
        except requests.exceptions.ConnectionError:
            logging.info("Error en servidor")
            QMessageBox.warning(self.dlgEOG, "Error", "Servidor no disponible")
        except (KeyboardInterrupt, SystemExit): raise
        except:
            logging.warning("Error en busqueda: " + str(sys.exc_info()[0]) + str(sys.exc_info()[1]))
            QMessageBox.warning(self.dlgEOG, "Error", "No se pueden asociar o desasociar parcelas sin superficie")

    """
        RUN METHODS
    """
    def runChangePass(self):
        self.whichDialog = "ChangePass"
        self.toggleEnableToolbarIcons(False)
        if self.first_start_ChangePass == True:
            self.first_start_ChangePass = False
            self.dlgPass = PassDialog()
            # Events
            self.dlgPass.closed.connect(self.toggleEnableToolbarIcons)
            self.dlgPass.rejected.connect(self.toggleEnableToolbarIcons)
            self.dlgPass.accepted.connect(self.toggleEnableToolbarIcons)
            self.dlgPass.lineEdit_pw_2.textChanged.connect(self.unfocusedChangePass)
            self.dlgPass.lineEdit_pw_1.textChanged.connect(self.unfocusedChangePass)

        self.dlgPass.lineEdit_pw_1.setText("")
        self.dlgPass.lineEdit_pw_2.setText("")
        self.dlgPass.pushButton.setEnabled(False)
        self.dlgPass.show()
        result = self.dlgPass.exec_()

        if result:
            data = {'id' : self.user_data['Id_Usuario'],
                    'pass': hashlib.md5(self.dlgPass.lineEdit_pw_1.text().encode("utf-8")).hexdigest()}
            self.waitMsg = self.messageWait("Espere mientras se procesa el cambio...")
            thread = self.ServerLoaderChangePass(self, data)
            thread.finished.connect(self.finishedChangePass)
            thread.failed.connect(self.failedChangePass)
            thread.start() 


    def BTtableHeaderClick(self,index):
        columns = ["id_tramite","numero","tipo","objeto","prioridad","fecha_venc"]
        column_to_sort = columns[index]
        self.dataBT["tramites"].sort(key = lambda f: str(f[column_to_sort]) if column_to_sort != "id_tramite" else f[column_to_sort],reverse = self.lastSortedColumnBT is not None)
        self.lastSortedColumnBT = column_to_sort if self.lastSortedColumnBT is None else None
        self.finishedBandejaTramites()


    def runBandeja(self):
        try:
            self.toggleEnableToolbarIcons(False)
            if self.first_start_BT == True:
                self.first_start_BT = False
                self.dlgBT = BandejaDialog()
                # Lock resizing for user
                self.dlgBT.setMaximumSize(self.dlgBT.size())
                self.dlgBT.setMinimumSize(self.dlgBT.size())
                self.defaultSizeBT = self.dlgBT.size()
                self.dlgBT.setGeometry((QDesktopWidget().screenGeometry().width() / 2) - (self.defaultSizeBT.width() / 2),(QDesktopWidget().screenGeometry().height() / 2) - (self.defaultSizeBT.height() / 2),self.defaultSizeBT.width(),self.defaultSizeBT.height())
                # table settings
                self.dlgBT.tableTramites.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
                self.dlgBT.tableTramites.horizontalHeader().setVisible(True) # only because QT Designer keeps setting this to False
                # Event handlers
                self.dlgBT.closed.connect(self.toggleEnableToolbarIcons)
                self.dlgBT.rejected.connect(self.toggleEnableToolbarIcons)
                self.dlgBT.prevButton.clicked.connect(lambda: self.changeBandejaPage("prev"))
                self.dlgBT.nextButton.clicked.connect(lambda: self.changeBandejaPage("next"))
                self.dlgBT.reloadButton.clicked.connect(lambda: self.changeBandejaPage("reload"))
                self.dlgBT.okButton.clicked.connect(self.procesarTramite)
                self.dlgBT.tableTramites.horizontalHeader().sectionClicked.connect(self.BTtableHeaderClick)
            self.securityBandejaTramite()
            self.bandejaPage = 0
            self.waitMsg = self.messageWait("Espere mientras se carga la bandeja de trámites...")
            thread = self.ServerLoaderBandejaTramites(self,self.bandejaPage)
            thread.finished.connect(self.finishedBandejaTramites)
            thread.failed.connect(self.failedBandejaTramites)
            thread.start()
        except Exception as e:
            # Manejo del error: registro, notificación al usuario, etc.
            logging.error("Error en Bandeja de Tramite: {}".format(str(e)))
            # Notificar al usuario del error
            self.showErrorMessage("Se ha producido un error al ejecutar la bandeja de trámites.")
            # Habilitar nuevamente los íconos de la barra de herramientas
            self.toggleEnableToolbarIcons(True)
        
    def runConsulta(self):
        """ Run method for Busqueda Dialog """
        self.whichDialog = "Consulta"
        self.toggleEnableToolbarIcons(False)
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start_Consulta == True:
            self.first_start_Consulta = False
            self.dlgC = ConsultaDialog()
            self.defaultSizeC = self.dlgC.size()
            self.smallerSizeC = QSize(self.defaultSizeC.width(),134)
            # Events
            self.dlgC.closed.connect(self.toggleEnableToolbarIcons)
            self.dlgC.rejected.connect(self.toggleEnableToolbarIcons)
            self.dlgC.buttonSearch.clicked.connect(self.performConsulta)
            self.dlgC.resultsTable.itemDoubleClicked.connect(self.consultaItemClicked)
            self.dlgC.resultsTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
            self.dlgC.resultsTable.horizontalHeader().setVisible(True) # only because QT Designer keeps setting this to False
            self.dlgC.comboObjeto.currentIndexChanged.connect(self.consultaComboChanged)

        # Lock resizing for user
        self.dlgC.setMaximumSize(self.smallerSizeC)
        self.dlgC.setMinimumSize(self.smallerSizeC)
        self.dlgC.setGeometry(int((QDesktopWidget().screenGeometry().width() / 2) - (self.smallerSizeC.width() / 2)),int((QDesktopWidget().screenGeometry().height() / 2) - (self.smallerSizeC.height() / 2)),self.smallerSizeC.width(),self.smallerSizeC.height())
        # Hide results label
        self.dlgC.labelNoEncontrado.setVisible(False)
        self.dlgC.labelResultados.setVisible(False)
        # clear search
        self.dlgC.lineSearch.clear()
        self.dlgC.show()

    def runEditObjetosGraficos(self):
        """ Run method for Edit Objetos Graficos Dialog """
        self.whichDialog = "EditObjetoGrafico"
        self.toggleEnableToolbarIcons(False)
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start_EditObjetoGrafico == True:
            self.first_start_EditObjetoGrafico = False
            self.dlgEOG = EditObjetoGraficoDialog()
            self.defaultSizeEOG = self.dlgEOG.size()
            # Lock resizing for user
            self.dlgEOG.setMaximumSize(self.defaultSizeEOG)
            self.dlgEOG.setMinimumSize(self.defaultSizeEOG)
            self.dlgEOG.setGeometry((QDesktopWidget().screenGeometry().width() / 2) - (self.defaultSizeEOG.width() / 2),(QDesktopWidget().screenGeometry().height() / 2) - (self.defaultSizeEOG.height() / 2),self.defaultSizeEOG.width(),self.defaultSizeEOG.height())
            # Table config
            self.dlgEOG.resultsTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
            self.dlgEOG.resultsTable.horizontalHeader().setVisible(True) # only because QT Designer keeps setting this to False
            self.dlgEOG.resultsTable.itemSelectionChanged.connect(self.EOGresultsTableItemSelected)
            self.dlgEOG.resultsTable.itemDoubleClicked.connect(self.consultaItemClicked)
            # Events
            self.dlgEOG.closed.connect(self.toggleEnableToolbarIcons)
            self.dlgEOG.rejected.connect(self.toggleEnableToolbarIcons)
            self.dlgEOG.buttonBuscar.clicked.connect(self.buscarObjetoABM)
            self.dlgEOG.buttonAsociar.clicked.connect(self.EOGasociarGeometria)
            self.dlgEOG.buttonDesasociar.clicked.connect(self.EOGdesasociarGeometria)
        
        self.securityABMObjetosGraficos()
        self.dlgEOG.lineBuscar.clear() # Clear search

        # Set combo/widget to parcela
        self.dlgEOG.comboObjeto.setCurrentIndex(0)
        # Hide label
        self.dlgEOG.labelNoEncontrado.setVisible(False)
        self.dlgEOG.labelResultados.setVisible(False)
        # Clear searchlist
        self.dlgEOG.resultsTable.clearSelection()
        self.dlgEOG.resultsTable.setRowCount(0)
        # Disable buttons
        self.buttonsToggleABM()
        # Show dialog
        self.dlgEOG.show()

    def runLogin(self):
        self.whichDialog = "Login"
        self.toggleEnableToolbarIcons(False)
        if self.first_start_Login == True:
            self.first_start_Login = False
            self.dlgLG = LoginDialog()
            # Lock resizing for user
            self.dlgLG.setMaximumSize(self.dlgLG.size())
            self.dlgLG.setMinimumSize(self.dlgLG.size())
            self.defaultSizeLG = self.dlgLG.size()
            self.dlgLG.setGeometry(int((QDesktopWidget().screenGeometry().width() / 2) - (self.defaultSizeLG.width() / 2)),int((QDesktopWidget().screenGeometry().height() / 2) - (self.defaultSizeLG.height() / 2)),self.defaultSizeLG.width(),self.defaultSizeLG.height())
            # Event handlers
            self.dlgLG.closed.connect(self.toggleEnableToolbarIcons)
            self.dlgLG.rejected.connect(self.toggleEnableToolbarIcons)
            self.dlgLG.buttonLogin.clicked.connect(self.attemptLogin)
            self.dlgLG.buttonSuperLogin.clicked.connect(lambda: self.attemptLogin(super = True))

        # Hide button
        #self.dlgLG.buttonSuperLogin.setVisible(False)
        # show the dialog
        self.dlgLG.show()

